<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Typora+Github 解决图片插入问题</title>
      <link href="/blog/2020/03/11/typora-github-jie-jue-tu-pian-cha-ru-wen-ti/"/>
      <url>/blog/2020/03/11/typora-github-jie-jue-tu-pian-cha-ru-wen-ti/</url>
      
        <content type="html"><![CDATA[<blockquote><p>目前较为好用的图床方案是PicGo+Github, 但受制于网络情况，有时会上传失败，并且操作繁琐，如果文章中插入图片很多，就更是糟糕了（因为每张图片都要经过一次上传和链接复制）。因此，这里推荐采用Typora+Github，实现本地上传，省略了PicGo的上传和链接复制操作，一次设置即可（苹果电脑有个专门的软件叫ipic 听说很好用，但是windows却没有）。</p><p>我博客用的是<strong>Hexo搭建</strong>，这里以此举例。（其他博客方案类似，重点是明白Typora配置方法，理解Github在其中的作用，即使不是用于微博写作，只要上传指定文件到Github，就可以访问到图片）。</p></blockquote><p><strong>缺点：</strong></p><p>此方法虽然能够实现网页浏览，但是当需要从网页复制内容时，图片会失效，因为并不是以网页链接的形式存储图片（图床）。所以<code>择情选择</code>，若只是为了发布到网页，这这个方法效率很高。个人的话，考虑到文章移植性和人性化，我还是选择图床操作，关于图床使用可参考其它文章。 </p><p>开始</p><h1 id="1-下载安装Typora"><a href="#1-下载安装Typora" class="headerlink" title="1 下载安装Typora"></a>1 下载安装Typora</h1><p>网上直接下载安装即可。</p><h1 id="2-新建图片文件"><a href="#2-新建图片文件" class="headerlink" title="2 新建图片文件"></a>2 新建图片文件</h1><p>在博客根目录下&gt;source下新建一个<code>imgs</code>文件夹</p><p><img src="https://cdn.jsdelivr.net/gh/Tian-JQ/images/img/20200311171843.png" alt=""></p><h1 id="3-配置Typora"><a href="#3-配置Typora" class="headerlink" title="3 配置Typora"></a>3 配置Typora</h1><p><img src="https://cdn.jsdelivr.net/gh/Tian-JQ/images/img/20200311171920.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/Tian-JQ/images/img/20200311171947.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/Tian-JQ/images/img/20200311172040.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/Tian-JQ/images/img/20200311172157.png" alt=""></p><p><strong>这里注意：根目录为source,不是imgs，否则会出错！</strong></p><p>文章开头出现此标准即为成功：</p><p><img src="https://cdn.jsdelivr.net/gh/Tian-JQ/images/img/20200311172217.png" alt=""></p><p>🆗，到这里，配置基本完成</p><h1 id="4-使用"><a href="#4-使用" class="headerlink" title="4 使用"></a>4 使用</h1><p>直接插入，复制，导入，均可！</p><p><strong>需要注意的是：</strong></p><p>每次编辑文档时，确保文档中出现这个图标 (若没有，且图片显示不成功，则操作以上步骤中的7-11步)</p><p><img src="https://cdn.jsdelivr.net/gh/Tian-JQ/images/img/20200311172236.png" alt="">))</p><p>并且图片地址格式为：</p><p><img src="https://cdn.jsdelivr.net/gh/Tian-JQ/images/img/20200311172258.png" alt=""></p><p>这种格式是错的(有两个 .. )：</p><p><img src="https://cdn.jsdelivr.net/gh/Tian-JQ/images/img/20200311172347.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/Tian-JQ/images/img/20200311175214.png" alt=""></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> github </tag>
            
            <tag> Hexo </tag>
            
            <tag> Typora </tag>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang-理解接口数据类型</title>
      <link href="/blog/2020/03/08/golang-li-jie-jie-kou-shu-ju-lei-xing/"/>
      <url>/blog/2020/03/08/golang-li-jie-jie-kou-shu-ju-lei-xing/</url>
      
        <content type="html"><![CDATA[<h2 id="认识接口"><a href="#认识接口" class="headerlink" title="认识接口"></a>认识接口</h2><p>Go 语言提供了另外一种数据类型即接口，它把所有的具有共性的方法定义在一起，任何其他类型只要实现了这些方法就是实现了这个接口。</p><p><strong>接口使用</strong></p><pre class=" language-go"><code class="language-go"><span class="token comment" spellcheck="true">/* 定义接口 */</span><span class="token keyword">type</span> interface_name <span class="token keyword">interface</span> <span class="token punctuation">{</span>   method_name1 <span class="token punctuation">[</span>return_type<span class="token punctuation">]</span>   method_name2 <span class="token punctuation">[</span>return_type<span class="token punctuation">]</span>   method_name3 <span class="token punctuation">[</span>return_type<span class="token punctuation">]</span>   <span class="token operator">...</span>   method_namen <span class="token punctuation">[</span>return_type<span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/* 定义结构体 */</span><span class="token keyword">type</span> struct_name <span class="token keyword">struct</span> <span class="token punctuation">{</span>   <span class="token comment" spellcheck="true">/* variables */</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/* 实现接口方法 */</span><span class="token keyword">func</span> <span class="token punctuation">(</span>struct_name_variable struct_name<span class="token punctuation">)</span> <span class="token function">method_name1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">[</span>return_type<span class="token punctuation">]</span> <span class="token punctuation">{</span>   <span class="token comment" spellcheck="true">/* 方法实现 */</span><span class="token punctuation">}</span><span class="token operator">...</span><span class="token keyword">func</span> <span class="token punctuation">(</span>struct_name_variable struct_name<span class="token punctuation">)</span> <span class="token function">method_namen</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">[</span>return_type<span class="token punctuation">]</span> <span class="token punctuation">{</span>   <span class="token comment" spellcheck="true">/* 方法实现*/</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/*方法调用*/</span>struct_name_variable<span class="token punctuation">.</span><span class="token function">method_name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> </code></pre><h2 id="理解接口和结构体"><a href="#理解接口和结构体" class="headerlink" title="理解接口和结构体"></a>理解接口和结构体</h2><h3 id="结构体是接口实现的载体。"><a href="#结构体是接口实现的载体。" class="headerlink" title="结构体是接口实现的载体。"></a>结构体是接口实现的载体。</h3><p>我们把结构体比作<code>机器人</code>，接口比作<code>外插芯片</code>。</p><p>假设结构体是一个机器人（机器人有很多类别，因为不同的机器人所拥有的属性和功能不一样，有快递机器人、家务机器人、工作机器人等等，所以结构体也可以自定义为各种类型，因为它可以包含不同的属性和方法）；</p><p>机器人的功能是可以通过外插芯片来扩展的（就像一个电脑U盘一样），可以在芯片中加入一系列类似的功能，我们把接口比作这个外插芯片；</p><p>这个芯片可以插在各种机器人身上使用，并且机器人能够根据芯片功能显示出不同的作用。</p><p>机器人需要执行某项功能，而这项功能在芯片中统一管理，则可以将芯片插入机器人身上，并将机器人需要的功能植入到机器人，机器人就获得了这项功能。</p><p>同理。许多有关联的方法可统一在接口中管理。当结构体需要用到接口中的功能时，将接口函数在结构体中实现，之后结构体即可调用该方法。</p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><pre class=" language-go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span>    <span class="token string">"fmt"</span><span class="token punctuation">)</span><span class="token keyword">type</span> Phone <span class="token keyword">interface</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//定义接口（生产芯片）</span>    <span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">type</span> NokiaPhone <span class="token keyword">struct</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//定义结构体1（生产机器人1号）</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token punctuation">(</span>nokiaPhone NokiaPhone<span class="token punctuation">)</span> <span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//方法实现（将芯片插入机器人1号，并植入芯片中的call功能）</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"I am Nokia, I can call you!"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">type</span> IPhone <span class="token keyword">struct</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//定义结构体2（生产机器人2号）</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token punctuation">(</span>iPhone IPhone<span class="token punctuation">)</span> <span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//方法实现（将芯片插入机器人2号，并植入芯片中的call功能）</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"I am iPhone, I can call you!"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> phone Phone    phone1 <span class="token operator">=</span> <span class="token function">new</span><span class="token punctuation">(</span>NokiaPhone<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">//结构体实例化（机器人1号出厂）</span>    phone1<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">//方法调用（机器人1号启动芯片植入的call功能）</span>    phone2 <span class="token operator">=</span> <span class="token function">new</span><span class="token punctuation">(</span>IPhone<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">//结构体实例化（机器人2号出厂）</span>    phone2<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">//方法调用（机器人2号启动芯片植入的call功能）</span><span class="token punctuation">}</span></code></pre><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><h3 id="空接口"><a href="#空接口" class="headerlink" title="空接口"></a>空接口</h3><p>空接口(interface{})不包含任何的方法，正因为如此，所有的类型都实现了空接口，因此空接口可以存储任意类型的数值。</p><pre class=" language-go"><code class="language-go"><span class="token keyword">type</span> Object <span class="token keyword">interface</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">type</span> Node <span class="token keyword">struct</span> <span class="token punctuation">{</span>    Data Object    Next <span class="token operator">*</span>Node<span class="token punctuation">}</span></code></pre><h3 id="this-习惯用法"><a href="#this-习惯用法" class="headerlink" title="this *习惯用法"></a>this *习惯用法</h3><pre class=" language-go"><code class="language-go"><span class="token comment" spellcheck="true">//判断是否为空的单链表</span><span class="token keyword">func</span> <span class="token punctuation">(</span>this <span class="token operator">*</span>List<span class="token punctuation">)</span> <span class="token function">IsEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">bool</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> this<span class="token punctuation">.</span>headNode <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token boolean">true</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token boolean">false</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>所列出的this只是变量名，人们用this作为变量名只是为了遵循方法实现的习惯。</p><h3 id="实例（单链表的实现）"><a href="#实例（单链表的实现）" class="headerlink" title="实例（单链表的实现）"></a>实例（单链表的实现）</h3><pre class=" language-go"><code class="language-go"><span class="token keyword">package</span> linkedList<span class="token keyword">type</span> Object <span class="token keyword">interface</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">type</span> Node <span class="token keyword">struct</span> <span class="token punctuation">{</span>    Data Object    Next <span class="token operator">*</span>Node<span class="token punctuation">}</span><span class="token keyword">type</span> List <span class="token keyword">struct</span> <span class="token punctuation">{</span>    headNode <span class="token operator">*</span>Node <span class="token comment" spellcheck="true">//头节点</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//判断是否为空的单链表</span><span class="token keyword">func</span> <span class="token punctuation">(</span>this <span class="token operator">*</span>List<span class="token punctuation">)</span> <span class="token function">IsEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">bool</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> this<span class="token punctuation">.</span>headNode <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token boolean">true</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token boolean">false</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//单链表的长度</span><span class="token keyword">func</span> <span class="token punctuation">(</span>this <span class="token operator">*</span>List<span class="token punctuation">)</span> <span class="token function">Length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">{</span>    cur <span class="token operator">:=</span> this<span class="token punctuation">.</span>headNode    count <span class="token operator">:=</span> <span class="token number">0</span>    <span class="token keyword">for</span> cur <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        count<span class="token operator">++</span>        cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>Next    <span class="token punctuation">}</span>    <span class="token keyword">return</span> count<span class="token punctuation">}</span><span class="token comment" spellcheck="true">//获取头部节点</span><span class="token keyword">func</span> <span class="token punctuation">(</span>this <span class="token operator">*</span>List<span class="token punctuation">)</span> <span class="token function">GetHeadNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span>Node <span class="token punctuation">{</span>    <span class="token keyword">return</span> this<span class="token punctuation">.</span>headNode<span class="token punctuation">}</span><span class="token comment" spellcheck="true">//从头部添加元素</span><span class="token keyword">func</span> <span class="token punctuation">(</span>this <span class="token operator">*</span>List<span class="token punctuation">)</span> <span class="token function">Add</span><span class="token punctuation">(</span>data Object<span class="token punctuation">)</span> <span class="token punctuation">{</span>    node <span class="token operator">:=</span> <span class="token operator">&amp;</span>Node<span class="token punctuation">{</span>Data<span class="token punctuation">:</span> data<span class="token punctuation">}</span>    node<span class="token punctuation">.</span>Next <span class="token operator">=</span> this<span class="token punctuation">.</span>headNode    this<span class="token punctuation">.</span>headNode <span class="token operator">=</span> node<span class="token punctuation">}</span><span class="token comment" spellcheck="true">//从尾部添加元素</span><span class="token keyword">func</span> <span class="token punctuation">(</span>this <span class="token operator">*</span>List<span class="token punctuation">)</span> <span class="token function">Append</span><span class="token punctuation">(</span>data Object<span class="token punctuation">)</span> <span class="token punctuation">{</span>    node <span class="token operator">:=</span> <span class="token operator">&amp;</span>Node<span class="token punctuation">{</span>Data<span class="token punctuation">:</span> data<span class="token punctuation">}</span>    <span class="token keyword">if</span> this<span class="token punctuation">.</span><span class="token function">IsEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        this<span class="token punctuation">.</span>headNode <span class="token operator">=</span> node    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        cur <span class="token operator">:=</span> this<span class="token punctuation">.</span>headNode        <span class="token keyword">for</span> cur<span class="token punctuation">.</span>Next <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>            cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>Next        <span class="token punctuation">}</span>        cur<span class="token punctuation">.</span>Next <span class="token operator">=</span> node    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//在指定位置添加元素</span><span class="token keyword">func</span> <span class="token punctuation">(</span>this <span class="token operator">*</span>List<span class="token punctuation">)</span> <span class="token function">Insert</span><span class="token punctuation">(</span>index <span class="token builtin">int</span><span class="token punctuation">,</span> data Object<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> index <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token punctuation">{</span>        this<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> index <span class="token operator">></span> this<span class="token punctuation">.</span><span class="token function">Length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        this<span class="token punctuation">.</span><span class="token function">Append</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        pre <span class="token operator">:=</span> this<span class="token punctuation">.</span>headNode        count <span class="token operator">:=</span> <span class="token number">0</span>        <span class="token keyword">for</span> count <span class="token operator">&lt;</span> <span class="token punctuation">(</span>index <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            pre <span class="token operator">=</span> pre<span class="token punctuation">.</span>Next            count<span class="token operator">++</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//当循环退出后，pre指向index -1的位置</span>        node <span class="token operator">:=</span> <span class="token operator">&amp;</span>Node<span class="token punctuation">{</span>Data<span class="token punctuation">:</span> data<span class="token punctuation">}</span>        node<span class="token punctuation">.</span>Next <span class="token operator">=</span> pre<span class="token punctuation">.</span>Next        pre<span class="token punctuation">.</span>Next <span class="token operator">=</span> node    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//删除指定元素</span><span class="token keyword">func</span> <span class="token punctuation">(</span>this <span class="token operator">*</span>List<span class="token punctuation">)</span> <span class="token function">Remove</span><span class="token punctuation">(</span>data Object<span class="token punctuation">)</span> <span class="token punctuation">{</span>    pre <span class="token operator">:=</span> this<span class="token punctuation">.</span>headNode    <span class="token keyword">if</span> pre<span class="token punctuation">.</span>Data <span class="token operator">==</span> data <span class="token punctuation">{</span>        this<span class="token punctuation">.</span>headNode <span class="token operator">=</span> pre<span class="token punctuation">.</span>Next    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> pre<span class="token punctuation">.</span>Next <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> pre<span class="token punctuation">.</span>Next<span class="token punctuation">.</span>Data <span class="token operator">==</span> data <span class="token punctuation">{</span>                pre<span class="token punctuation">.</span>Next <span class="token operator">=</span> pre<span class="token punctuation">.</span>Next<span class="token punctuation">.</span>Next            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                pre <span class="token operator">=</span> pre<span class="token punctuation">.</span>Next            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//删除指定位置的元素</span><span class="token keyword">func</span> <span class="token punctuation">(</span>this <span class="token operator">*</span>List<span class="token punctuation">)</span> <span class="token function">RemoveAtIndex</span><span class="token punctuation">(</span>index <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    pre <span class="token operator">:=</span> this<span class="token punctuation">.</span>headNode    <span class="token keyword">if</span> index <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token punctuation">{</span>        this<span class="token punctuation">.</span>headNode <span class="token operator">=</span> pre<span class="token punctuation">.</span>Next    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> index <span class="token operator">>=</span> this<span class="token punctuation">.</span><span class="token function">Length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//报错 err</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        count <span class="token operator">:=</span> <span class="token number">0</span> <span class="token comment" spellcheck="true">//index = 3</span>        <span class="token keyword">for</span> count <span class="token operator">!=</span> <span class="token punctuation">(</span>index<span class="token number">-1</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> pre<span class="token punctuation">.</span>Next <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>            count<span class="token operator">++</span>        <span class="token comment" spellcheck="true">//2</span>            pre <span class="token operator">=</span> pre<span class="token punctuation">.</span>Next <span class="token comment" spellcheck="true">//2</span>        <span class="token punctuation">}</span>        pre<span class="token punctuation">.</span>Next <span class="token operator">=</span> pre<span class="token punctuation">.</span>Next<span class="token punctuation">.</span>Next    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//是否包含某个元素</span><span class="token keyword">func</span> <span class="token punctuation">(</span>this <span class="token operator">*</span>List<span class="token punctuation">)</span> <span class="token function">Contain</span><span class="token punctuation">(</span>data Object<span class="token punctuation">)</span> <span class="token builtin">bool</span> <span class="token punctuation">{</span>    cur <span class="token operator">:=</span> this<span class="token punctuation">.</span>headNode    <span class="token keyword">for</span> cur <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> cur<span class="token punctuation">.</span>Data <span class="token operator">==</span> data <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token boolean">true</span>        <span class="token punctuation">}</span>        cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>Next    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">}</span></code></pre><p>测试代码在main.go中，相关测试如下</p><pre class=" language-go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span>    <span class="token string">"algorithm/linkedList"</span>    <span class="token string">"fmt"</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    list <span class="token operator">:=</span> linkedList<span class="token punctuation">.</span>List<span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//1.往单链表末尾追加元素2, 3, 4, 5</span>    list<span class="token punctuation">.</span><span class="token function">Append</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    list<span class="token punctuation">.</span><span class="token function">Append</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>    list<span class="token punctuation">.</span><span class="token function">Append</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>    list<span class="token punctuation">.</span><span class="token function">Append</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">//2.从头部添加元素head_node</span>    list<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token string">"head_node"</span><span class="token punctuation">)</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"长度======"</span><span class="token punctuation">,</span> list<span class="token punctuation">.</span><span class="token function">Length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">//3.判断是否为空链表</span>    <span class="token builtin">bool</span> <span class="token operator">:=</span> list<span class="token punctuation">.</span><span class="token function">IsEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token builtin">bool</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">//4.在指定位置2插入元素 2indexValue</span>    list<span class="token punctuation">.</span><span class="token function">Insert</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">"2_index_value"</span><span class="token punctuation">)</span>    <span class="token function">travselLinkList</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>list<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">//5.是否包含元素2_index_value</span>    isContain <span class="token operator">:=</span> list<span class="token punctuation">.</span><span class="token function">Contain</span><span class="token punctuation">(</span><span class="token string">"2_index_value"</span><span class="token punctuation">)</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"isContain[2_index_value]:"</span><span class="token punctuation">,</span> isContain<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">//6.删除元素2_index_value</span>    list<span class="token punctuation">.</span><span class="token function">Remove</span><span class="token punctuation">(</span><span class="token string">"2_index_value"</span><span class="token punctuation">)</span>    <span class="token function">travselLinkList</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>list<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">//7.从位置2删除元素</span>    list<span class="token punctuation">.</span><span class="token function">RemoveAtIndex</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>    <span class="token function">travselLinkList</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>list<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">travselLinkList</span><span class="token punctuation">(</span>list <span class="token operator">*</span>linkedList<span class="token punctuation">.</span>List<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//遍历</span>    head <span class="token operator">:=</span> list<span class="token punctuation">.</span><span class="token function">GetHeadNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> head <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>head<span class="token punctuation">.</span>Data<span class="token punctuation">)</span>        head <span class="token operator">=</span> head<span class="token punctuation">.</span>Next    <span class="token punctuation">}</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"--------------------"</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VirtualBox 安装配置</title>
      <link href="/blog/2020/03/02/virtualbox-an-zhuang-pei-zhi/"/>
      <url>/blog/2020/03/02/virtualbox-an-zhuang-pei-zhi/</url>
      
        <content type="html"><![CDATA[<p>VirtualBox虚拟机与Linux系统的安装配置（以安装一个名为Hadoop的Ubuntu-Linux为例）</p><h2 id="VirtualBox虚拟机下载安装"><a href="#VirtualBox虚拟机下载安装" class="headerlink" title="VirtualBox虚拟机下载安装"></a>VirtualBox虚拟机下载安装</h2><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p><a href="https://www.virtualbox.org/wiki/Downloads" target="_blank" rel="noopener">下载地址</a></p><p>选择对应的版本下载</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p><img src="https://cdn.jsdelivr.net/gh/Tian-JQ/images/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20200302003427.png" alt=""></p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p><img src="https://cdn.jsdelivr.net/gh/Tian-JQ/images/img/a2.png" alt=""></p><p>1.设置存储文件夹：管理-全局设定-常规-默认虚拟电脑位置-其他-更改到其他盘符如D:\Virtual</p><p><img src="https://cdn.jsdelivr.net/gh/Tian-JQ/images/img/a3.png" alt=""></p><p>2.创建虚拟机：点新建</p><p><img src="https://cdn.jsdelivr.net/gh/Tian-JQ/images/img/a4.png" alt=""></p><p>设置内存：根据电脑配置，2G以下容易卡顿，推荐4G</p><p><img src="https://cdn.jsdelivr.net/gh/Tian-JQ/images/img/a5.png" alt=""></p><p>设置虚拟硬盘位置和大小：根据配置，设置大小</p><p><img src="https://cdn.jsdelivr.net/gh/Tian-JQ/images/img/a6.png" alt=""></p><p>创建完成</p><h2 id="Ubuntu下载安装"><a href="#Ubuntu下载安装" class="headerlink" title="Ubuntu下载安装"></a>Ubuntu下载安装</h2><h3 id="下载-1"><a href="#下载-1" class="headerlink" title="下载"></a>下载</h3><p><a href="https://ubuntu.com/download/desktop" target="_blank" rel="noopener">下载地址</a></p><p>选择LTS版本</p><h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3><p>1.在VirtualBox管理器中选择刚刚创建的Hadoop虚拟机<br>2.设置-存储-光驱（没有盘片）-右侧蓝色光盘图标-Choose a disk file…</p><p><img src="https://cdn.jsdelivr.net/gh/Tian-JQ/images/img/a7.png" alt=""></p><p>选取下载好的Ubuntu光盘文件，OK</p><p>3.启动虚拟机-安装Ubuntu</p><p><img src="https://cdn.jsdelivr.net/gh/Tian-JQ/images/img/a8.png" alt=""></p><p>勾选”为图形或无线硬件，以及其他媒体格式安装第三方软件”</p><p><img src="https://cdn.jsdelivr.net/gh/Tian-JQ/images/img/a9.png" alt=""></p><p>清除整个磁盘并安装Ubuntu</p><p><img src="https://cdn.jsdelivr.net/gh/Tian-JQ/images/img/a10.png" alt=""></p><p>填写所在地：如Beijing<br>设置个人信息</p><p><img src="https://cdn.jsdelivr.net/gh/Tian-JQ/images/img/a11.png" alt=""></p><p>重新启动后则安装完毕</p><h3 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h3><h4 id="共享粘贴板"><a href="#共享粘贴板" class="headerlink" title="共享粘贴板"></a>共享粘贴板</h4><p>设置虚拟机为“双向”共享粘贴,重启虚拟机即可</p><p><img src="https://cdn.jsdelivr.net/gh/Tian-JQ/images/img/a12.png" alt=""></p><h4 id="共享文件夹"><a href="#共享文件夹" class="headerlink" title="共享文件夹"></a>共享文件夹</h4><p><a href="https://www.cnblogs.com/z12568/p/9837960.html" target="_blank" rel="noopener">链接</a></p><p>注意：</p><ol><li>设置共享文件夹时要勾选自动挂载</li><li>完成后重启虚拟机才能出现共享文件夹</li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 互联网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VirtualBox </tag>
            
            <tag> Ubuntu </tag>
            
            <tag> Linux </tag>
            
            <tag> 虚拟机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法解读-Z字形变换(Go)</title>
      <link href="/blog/2020/02/25/suan-fa-jie-du-z-zi-xing-bian-huan/"/>
      <url>/blog/2020/02/25/suan-fa-jie-du-z-zi-xing-bian-huan/</url>
      
        <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p><a href="https://leetcode-cn.com/problems/zigzag-conversion/" target="_blank" rel="noopener">LeetCode#6</a></p><p>将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。</p><p>比如输入字符串为 “LEETCODEISHIRING” 行数为 3 时，排列如下：</p><pre><code>L   C   I   RE T O E S I I GE   D   H   N</code></pre><p>之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：”LCIRETOESIIGEDHN”。</p><p>请你实现这个将字符串进行指定行数变换的函数：</p><pre><code>string convert(string s, int numRows);</code></pre><p>示例 1:</p><pre><code>输入: s = "LEETCODEISHIRING", numRows = 3输出: "LCIRETOESIIGEDHN"示例 2:输入: s = "LEETCODEISHIRING", numRows = 4输出: "LDREOEIIECIHNTSG"</code></pre><p>解释:</p><pre><code>L     D     RE   O E   I IE C   I H   NT     S     G</code></pre><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><a href="https://leetcode-cn.com/problems/zigzag-conversion/solution/zzi-xing-bian-huan-by-jyd/" target="_blank" rel="noopener">解题思路</a></h3><p>设置numRows个数组（以下程序中用切片实现），根据规律，依次将元素放入数组中，最后合并各个数组。</p><img src="https://cdn.jsdelivr.net/gh/Tian-JQ/images/img/aaa.png" style="zoom:50%;"><h3 id="源程序（Go）"><a href="#源程序（Go）" class="headerlink" title="源程序（Go）"></a>源程序（Go）</h3><pre class=" language-go"><code class="language-go"><span class="token comment" spellcheck="true">//Convert Z字型变换</span><span class="token keyword">func</span> <span class="token function">Convert</span><span class="token punctuation">(</span>s <span class="token builtin">string</span><span class="token punctuation">,</span> numRows <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">string</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> utf8<span class="token punctuation">.</span><span class="token function">RuneCountInString</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token number">1</span> <span class="token operator">||</span> numRows <span class="token operator">==</span> <span class="token number">1</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> s    <span class="token punctuation">}</span>    list <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">,</span> numRows<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//不能是: var list [numRows][]byte</span>    <span class="token keyword">var</span> result <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span>    index <span class="token operator">:=</span> <span class="token number">0</span>    flag <span class="token operator">:=</span> <span class="token number">1</span>    <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> utf8<span class="token punctuation">.</span><span class="token function">RuneCountInString</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>        list<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>list<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">,</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> flag <span class="token operator">==</span> <span class="token number">1</span> <span class="token punctuation">{</span>            index<span class="token operator">++</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            index<span class="token operator">--</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> index <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> index <span class="token operator">==</span> numRows<span class="token number">-1</span> <span class="token punctuation">{</span>            flag <span class="token operator">=</span> <span class="token operator">-</span>flag <span class="token comment" spellcheck="true">//flag标签实现方向反转，放入数组</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> numRows<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> j <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> utf8<span class="token punctuation">.</span><span class="token function">RuneCount</span><span class="token punctuation">(</span>list<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> j<span class="token operator">++</span> <span class="token punctuation">{</span>            result <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>result<span class="token punctuation">,</span> list<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token function">string</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><h2 id="解读"><a href="#解读" class="headerlink" title="解读"></a>解读</h2><ol><li><h3 id="Go中多维切片实现"><a href="#Go中多维切片实现" class="headerlink" title="Go中多维切片实现"></a>Go中多维切片实现</h3><pre class=" language-go"><code class="language-go">list <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">,</span> numRows<span class="token punctuation">)</span></code></pre><p>错误用法：</p><pre><code>var list [numRows][]byte</code></pre><p>如果这样写会报错，动态值不能直接放在括号中定义数组或则切片，而应该使用make进行定义</p><p>这是golang 数组初始化的一个坑</p><p>例如：</p><pre class=" language-Go"><code class="language-Go">//Length 是动态的值var array [length]int</code></pre><p>报错：non-constant array bound length</p><p>动态数组应该这样写</p><pre class=" language-Go"><code class="language-Go">array := make([]int, length)</code></pre></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> 算法 </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang-了解rune数据类型</title>
      <link href="/blog/2020/02/24/golang-liao-jie-rune-shu-ju-lei-xing/"/>
      <url>/blog/2020/02/24/golang-liao-jie-rune-shu-ju-lei-xing/</url>
      
        <content type="html"><![CDATA[<h2 id="Golang中rune数据类型是什么？"><a href="#Golang中rune数据类型是什么？" class="headerlink" title="Golang中rune数据类型是什么？"></a>Golang中rune数据类型是什么？</h2><h3 id="官方解释"><a href="#官方解释" class="headerlink" title="官方解释"></a>官方解释</h3><pre class=" language-golang"><code class="language-golang">// rune is an alias for int32 and is equivalent to int32 in all ways. It is// used, by convention, to distinguish character values from integer values.//int32的别名，几乎在所有方面等同于int32//它用来区分字符值和整数值type rune = int32</code></pre><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><pre class=" language-golang"><code class="language-golang">package mainimport "fmt"func main() {    var str = "hello 你好"    fmt.Println("len(str):", len(str))}</code></pre><p>我们猜测结果应该是：8（5个字符1个空格2个汉字）。那么正确答案是多少呢？</p><img src="https:////upload-images.jianshu.io/upload_images/830585-fe29ebd0df048249.png?imageMogr2/auto-orient/strip|imageView2/2/w/870/format/webp" alt="img" style="zoom:50%;"><p><strong><em>咦…结果居然是12，这是为什么呢！？\</em></strong></p><blockquote><p>golang中string底层是通过byte数组实现的。中文字符在unicode下占2个字节，在utf-8编码下占3个字节，而golang默认编码正好是utf-8。</p></blockquote><p>那么？如果我们预期想得到一个<strong>字符串的长度</strong>，而不是字符串底层占得<strong>字节长度</strong>，该怎么办呢？？？</p><pre class=" language-golang"><code class="language-golang">package mainimport (    "fmt"    "unicode/utf8")func main() {    var str = "hello 你好"    //golang中string底层是通过byte数组实现的，所以直接求len 实际是在按字节长度计算  所以一个汉字占3个字节 算了3个长度    fmt.Println("len(str):", len(str))    //以下两种都可以得到str的字符串长度    //golang中的unicode/utf8包提供了用utf-8获取长度的方法    fmt.Println("RuneCountInString:", utf8.RuneCountInString(str))    //通过rune类型处理unicode字符    fmt.Println("rune:", len([]rune(str)))}</code></pre><p>运行结果：</p><img src="https:////upload-images.jianshu.io/upload_images/830585-1f6603c94152addf.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp" alt="img" style="zoom:50%;"><h3 id="byte数据类型"><a href="#byte数据类型" class="headerlink" title="byte数据类型"></a><strong>byte数据类型</strong></h3><p>与rune相似，它们都是用来表示字符类型的变量类型。它们的不同在于：</p><ul><li>byte 等同于uint8，常用来处理ascii字符</li><li>rune 等同于int32, 常用来处理<code>unicode</code>或<code>utf-8</code>字符</li></ul><hr><blockquote><p>参考：<a href="https://www.jianshu.com/p/4fbf529926ca" target="_blank" rel="noopener">https://www.jianshu.com/p/4fbf529926ca</a></p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法解读-最长回文字符串（Go）</title>
      <link href="/blog/2020/02/24/suan-fa-jie-du-zui-chang-hui-wen-zi-fu-chuan-go/"/>
      <url>/blog/2020/02/24/suan-fa-jie-du-zui-chang-hui-wen-zi-fu-chuan-go/</url>
      
        <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/" target="_blank" rel="noopener">LeetCode#5</a></p><p>给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。</p><p>示例 1：</p><pre><code>输入: "babad"输出: "bab"注意: "aba" 也是一个有效答案。</code></pre><p>示例 2：</p><pre><code>输入: "cbbd"输出: "bb"</code></pre><h2 id="解题-中心扩展算法"><a href="#解题-中心扩展算法" class="headerlink" title="解题-中心扩展算法"></a>解题-中心扩展算法</h2><pre class=" language-go"><code class="language-go"><span class="token comment" spellcheck="true">//求最长回文字符串</span><span class="token comment" spellcheck="true">//中心扩展算法</span><span class="token keyword">func</span> <span class="token function">longestPalindrome</span><span class="token punctuation">(</span>s <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token builtin">string</span> <span class="token punctuation">{</span>    start <span class="token operator">:=</span> <span class="token number">0</span>    end <span class="token operator">:=</span> <span class="token number">0</span>    <span class="token keyword">var</span> len1<span class="token punctuation">,</span> len2<span class="token punctuation">,</span> <span class="token builtin">len</span> <span class="token builtin">int</span>    <span class="token comment" spellcheck="true">//排除s长度&lt;=1的情况</span>    <span class="token keyword">if</span> utf8<span class="token punctuation">.</span><span class="token function">RuneCountInString</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">1</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">""</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//避免超时（LeetCode提交时会有超时的情况，比如出现1000个'b'构成的字符串,此步骤可避免）</span>    <span class="token keyword">if</span> s <span class="token operator">==</span> <span class="token function">reverse</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> s    <span class="token punctuation">}</span>    <span class="token keyword">if</span> utf8<span class="token punctuation">.</span><span class="token function">RuneCountInString</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> s    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//循环调用中心扩展算法</span>    <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> utf8<span class="token punctuation">.</span><span class="token function">RuneCountInString</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>        len1 <span class="token operator">=</span> <span class="token function">centerexpand</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> i<span class="token punctuation">,</span> i<span class="token punctuation">)</span>        len2 <span class="token operator">=</span> <span class="token function">centerexpand</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> i<span class="token punctuation">,</span> i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> len1 <span class="token operator">>=</span> len2 <span class="token punctuation">{</span>            <span class="token builtin">len</span> <span class="token operator">=</span> len1        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token builtin">len</span> <span class="token operator">=</span> len2        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token builtin">len</span> <span class="token operator">></span> end<span class="token operator">-</span>start <span class="token punctuation">{</span>            start <span class="token operator">=</span> i <span class="token operator">-</span> <span class="token punctuation">(</span><span class="token builtin">len</span><span class="token number">-1</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span>            end <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token builtin">len</span><span class="token operator">/</span><span class="token number">2</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> s<span class="token punctuation">[</span>start<span class="token punctuation">:</span><span class="token punctuation">(</span>end <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//中心扩展算法</span><span class="token keyword">func</span> <span class="token function">centerexpand</span><span class="token punctuation">(</span>s <span class="token builtin">string</span><span class="token punctuation">,</span> left <span class="token builtin">int</span><span class="token punctuation">,</span> right <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> left <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> right <span class="token operator">&lt;</span> utf8<span class="token punctuation">.</span><span class="token function">RuneCountInString</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> s<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">==</span> s<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token punctuation">{</span>        left<span class="token operator">--</span>        right<span class="token operator">++</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> right <span class="token operator">-</span> left <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//字符串反转</span><span class="token keyword">func</span> <span class="token function">reverse</span><span class="token punctuation">(</span>src <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token builtin">string</span> <span class="token punctuation">{</span>    dst <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">rune</span><span class="token punctuation">(</span>src<span class="token punctuation">)</span>    <span class="token builtin">len</span> <span class="token operator">:=</span> <span class="token function">len</span><span class="token punctuation">(</span>dst<span class="token punctuation">)</span>    <span class="token keyword">var</span> result <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">rune</span>    result <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">rune</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token builtin">len</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span> <span class="token punctuation">{</span>        result <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>result<span class="token punctuation">,</span> dst<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token function">string</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><h2 id="解读"><a href="#解读" class="headerlink" title="解读"></a>解读</h2><ol><li><h3 id="rune数据类型？"><a href="#rune数据类型？" class="headerlink" title="rune数据类型？"></a><a href="https://tian-jq.github.io/2020/02/24/suan-fa-jie-du-zui-chang-hui-wen-zi-fu-chuan-go/" target="_blank" rel="noopener">rune数据类型？</a></h3></li><li><h3 id="Golang-与python中的字符串反转"><a href="#Golang-与python中的字符串反转" class="headerlink" title="Golang 与python中的字符串反转"></a>Golang 与python中的字符串反转</h3><p>在go中，需要用rune来处理，因为涉及到中文或者一些字符ASCII编码大于255的。</p><pre><code>func main() {  fmt.Println(reverse("Golang python"))}func reverse(src string) string {  dst := []rune(src)  len := len(dst)  var result []rune  result = make([]rune, 0)  for i := len - 1; i &gt;= 0; i-- {   result = append(result, dst[i])  }  return string(result)}</code></pre><p>而在python中，有几种方法，一个是list的操作，一个是系统的自带的函数，还有一个采用上面的遍历的方法</p><pre><code>#方法1--------------------------------------s = 'Golang python'print (s[::-1])#方法2--------------------------------------s = 'Golang python'l = list(s)l.reverse()print (''.join(l) )#方法3--------------------------------------s = 'Golang python'str=[]k=0for i in s:  str.append(s[len(s)-1-k])  k=k+1print (''.join(str) )#方法4--------------------------------------s = 'Golang python'str=[]for i in s:  str.insert(0,i)print (''.join(str) )</code></pre></li><li><h3 id="Golang-与python中的字符串长度"><a href="#Golang-与python中的字符串长度" class="headerlink" title="Golang 与python中的字符串长度"></a><a href="https://tian-jq.github.io/2020/02/24/suan-fa-jie-du-zui-chang-hui-wen-zi-fu-chuan-go/" target="_blank" rel="noopener">Golang 与python中的字符串长度</a></h3></li><li><h3 id="中心扩展算法"><a href="#中心扩展算法" class="headerlink" title="中心扩展算法"></a>中心扩展算法</h3><p>回文中心的两侧互为镜像， 因此，回文可以从它的中心展开，并且只有 （2n−1） 个这样的中心。</p><p>你可能会问，为什么会是 2n −1 个，而不是 n 个中心？原因在于所含字母数为偶数的回文的中心可以处于两字母之间（例如 \textrm{“abba”}“abba” 的中心在两个 \textrm{‘b’}‘b’ 之间）。</p></li></ol><p>。 </p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> 算法 </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo中遇到的Bug</title>
      <link href="/blog/2020/02/20/hexo-zhong-yu-dao-de-bug/"/>
      <url>/blog/2020/02/20/hexo-zhong-yu-dao-de-bug/</url>
      
        <content type="html"><![CDATA[<h2 id="一-Hexo-d显示成功，本地正常运行，但远程不能显示网页的问题"><a href="#一-Hexo-d显示成功，本地正常运行，但远程不能显示网页的问题" class="headerlink" title="一 Hexo d显示成功，本地正常运行，但远程不能显示网页的问题"></a>一 <code>Hexo d</code>显示成功，本地正常运行，但远程不能显示网页的问题</h2><p><strong>解决办法：</strong></p><ol><li><p>删除<code>.deploy_git</code>文件夹;</p><p><img src="https://cdn.jsdelivr.net/gh/Tian-JQ/images/img/blog8.png" alt=""></p></li><li><p><code>hexo c</code> 清理；</p><p><code>hexo g</code>生成页面；</p><p><code>hexo d</code>远程布置；</p><p>（以上三步可直接通过命令：<code>hexo c &amp;&amp; hexo g &amp;&amp; hexo d</code> 完成）</p></li><li><p>完成</p></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bug </tag>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GitHub中遇到的Bug</title>
      <link href="/blog/2020/02/20/github-zhong-yu-dao-de-bug/"/>
      <url>/blog/2020/02/20/github-zhong-yu-dao-de-bug/</url>
      
        <content type="html"><![CDATA[<h2 id="1-GitHub无法访问的问题"><a href="#1-GitHub无法访问的问题" class="headerlink" title="1 GitHub无法访问的问题"></a>1 GitHub无法访问的问题</h2><p><strong>1 原理</strong>：</p><p>访问网址时先搜索<code>hosts</code>文件，如果由网址对应的ip则不需要dns域名解析，因此可以将网址的ip配成静态ip，减少解析过程，提高访问速度。</p><p><strong>2 问题解决</strong>：</p><p>使用记事本打开<code>hosts文件</code>（win10的位置为C:\Windows\System32\drivers\etc），在hosts文件最下面增加：</p><pre><code>192.30.253.113   github.com185.199.108.153  github.github.io151.101.72.133   assets-cdn.github.com151.101.185.194  github.global.ssl.fastly.net</code></pre><p>2.2 打开<code>cmd</code>:</p><p>执行：<code>ipconfig /flushdns</code></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> github </category>
          
      </categories>
      
      
        <tags>
            
            <tag> github </tag>
            
            <tag> bug </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git基础</title>
      <link href="/blog/2020/02/15/git-ji-chu/"/>
      <url>/blog/2020/02/15/git-ji-chu/</url>
      
        <content type="html"><![CDATA[<h2 id="版本控制器"><a href="#版本控制器" class="headerlink" title="版本控制器"></a>版本控制器</h2><p>版本控制是我们开发软件时的必备工作，将文件的版本进行系统的管理，不仅仅可以帮助我们灵活操作文件，也能简化我们开发的流程。</p><p>不使用版本管理器的情况下，如果想要对文件的版本进行管理，需要将不同版本的文件分别存储起来，并分别命名，这样我们的文件夹就会类似这样：</p><p><img src="https://cdn.jsdelivr.net/gh/Tian-JQ/images/img/blog1.png" alt=""></p><p>随着新版本的迭代，我们的文件则越来越多，也越来越难管理。在团队开发时，如果多人同时对一个文件进行操作，则需要各自保存不同的版本，然后集中审核内容。可想而知，在改动幅度大，人数多的情况下，使用传统方式来开发简直就是噩梦。</p><p>而版本控制器就是一个解决这些痛点的神奇软件，它不仅仅可以帮助我们记录每次文件的改动，还可以让同事协同编辑，不仅仅提升了我们个人的开发效率，更简化了团队开发的难度。</p><p>版本控制器示意图：</p><p><img src="https://cdn.jsdelivr.net/gh/Tian-JQ/images/img/blog2.png" alt=""></p><p>市面上曾经出现过很多版本控制器，比如SCCS, RCS, CVS, SVN, BitKeeperSCM，但是都不大好用。在2005年，大牛Linux Torvalds（Linux内核的最早作者）开发出了分布式版本控制器Git，因为它的灵活性和优越性，Git的用户成指数级上升，如今已经发展成了最受欢迎的版本控制器，奠定了版本控制领域的垄断地位。</p><p>补充说明：所有的版本控制器系统，只能跟踪文本文件的改动，比如txt文件、网页和所有的程序源代码等等。版本控制器可以追踪每次的改动，比如在第7行添加了新的单词”Git”，在第8行删除了”Max”之类的具体修改信息。但是图片、视频、微软Word这类二进制文件，虽然版本控制器也可以追踪管理，比如从50KB改成了40KB，但是具体改了什么，是没法知道的。</p><h2 id="Git安装"><a href="#Git安装" class="headerlink" title="Git安装"></a>Git安装</h2><h3 id="Mac"><a href="#Mac" class="headerlink" title="Mac"></a>Mac</h3><p>使用MacOS的朋友有两种方法安装Git，第一种是先安装homebrew，然后通过homebrew安装Git，具体方法可以参观官网：<a href="https://brew.sh/" target="_blank" rel="noopener">https://brew.sh</a>。第二种方法比较方便，直接下载官方安装包<a href="https://git-scm.com/download/mac" target="_blank" rel="noopener">https://git-scm.com/download/mac</a></p><h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><p>Windows的朋友可以直接下载安装包<a href="https://git-scm.com/download/win，根据提示逐步完成。安装完成后，会创建一个git的文件夹，里面有个程序叫git" target="_blank" rel="noopener">https://git-scm.com/download/win，根据提示逐步完成。安装完成后，会创建一个git的文件夹，里面有个程序叫git</a> bash，打开git bash就能在一个Unix环境中使用Git了。</p><h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><p>使用Linux的小伙伴们，只要打开Terminal，输入以下的指令即可：</p><pre><code># Ubuntu user$ sudo apt-get install git-all# Fedora user$ sudo yum install git-all</code></pre><h2 id="创建版本库"><a href="#创建版本库" class="headerlink" title="创建版本库"></a>创建版本库</h2><p>版本库（repository）是一个Git会一直追踪的目录，这个目录中的所有文件的改动，包括各个文件的增加、删除和改动，都会被Git识别出来，以便Git可以追踪目录历史，并在将来某个时刻随时还原。</p><p>首先我们先把我们的个人信息告诉git，包括名字和邮箱，这样git就能知道我们的身份，更好地管理每个版本库的贡献者。</p><pre><code>$ git config --global user.name "yourname"$ git config --global user.name "youremail@gmail.com"</code></pre><p>我们使用<code>git config</code>加上—global参数，来设置全局配置，这样所有的版本库都会认识我们的身份，当然也可以为特定版本库指定不同的用户名和邮箱，这里我们直接使用这种省事的方法。</p><p>创建一个版本库很简单，第一步先创建一个空目录，然后进入新创建的目录，使用<code>git init</code>命令：</p><pre><code>$ mkdir new_repo$ cd new_repo$ git init</code></pre><p>这样一个Git版本库就创建好了，此时当前目录中还多了一个 .git 目录，这个目录中的信息可以帮助Git来跟踪管理版本库，所以千万不能删除。（.git目录是隐藏目录，需要使用 ls -ah 命令才能看到）</p><p>要注意的是，我们不一定要使用空目录作为版本库，<strong>设定已有内容的目录为版本库</strong>也是可以的。</p><p>现在我们在new_repo目录中编写一个new_file.txt文件，内容如下：</p><pre><code>Git is a distributed version-control system.Git is awesome.</code></pre><p>然后我们使用<code>git add</code>将新文件添加到仓库：</p><pre><code>$ git add new_file.txt</code></pre><p>然后我们再使用 <code>git commit</code> 将文件提交到仓库，并输入说明这次改动的内容：</p><pre><code>$ git commit -m "Created a new file"</code></pre><p>-m 之后的内容虽然可以是任意内容，但是最好是有意义的文字说明，这样才能从历史记录中方便地查找改动记录。</p><p>git commit 运行成功后，命令行中会提示1 file changed: 2 insertions，这样我们就知道有哪些具体的变动了。</p><p>成功创建了一个新文件后，我们可以继续工作，对新文件 new_file.txt 进行修改，将内容改成如下：</p><pre><code>Git is popular.Git is free.</code></pre><p>然后我们运行 <code>git status</code> 查看结果：</p><pre><code>$ git statusOn branch masterChanges not staged for commit:  (use "git add &lt;file&gt;..." to update what will be committed)  (use "git checkout -- &lt;file&gt;..." to discard changes in working directory)    modified:   new_file.txtno changes added to commit (use "git add" and/or "git commit -a")</code></pre><p><code>git status</code>可以帮助我们了解版本库当前的状态，上面的结果告诉我们 new_file.txt 被修改过了，但是新的修改没有被提交。我们还可以使用 <code>git diff</code> 来查看具体被修改的内容：</p><pre><code>$ git diffdiff --git a/new_file.txt b/new_file.txtindex 1647185..1c140a4 100644--- a/new_file.txt+++ b/new_file.txt@@ -1,2 +1,2 @@-Git is a distributed version-control system.-Git is awesome.+Git is popular.+Git is free.</code></pre><p>确定我们要修改的内容后，我们使用 git add new_file.txt 将修改过的文件添加至版本库。这个时候再使用 git status 查看，你会得到以下的信息：</p><pre><code>$ git add new_file.txt $ git statusOn branch masterChanges to be committed:  (use "git restage HEAD &lt;file&gt;..." to unstage)    modified:   new_file.txt</code></pre><p>这告诉我们将要被提交的修改包括 new_file.txt，是时候提交了，我们还是直接使用 git commit 加上提交说明即可：</p><pre><code>$ git commit -m "Modified the first two lines of new file"</code></pre><p>然后我们再使用 git status 就会看到当前目录是干净的，没有需要提交的修改：</p><pre><code>On branch masternothing to commit, working tree clean</code></pre><p>注意：任何没有使用git add将其加入staged状态的文件，都没法使用commit提交其修改。</p><h2 id="版本的增删改查、版本回退"><a href="#版本的增删改查、版本回退" class="headerlink" title="版本的增删改查、版本回退"></a>版本的增删改查、版本回退</h2><h3 id="增删查改"><a href="#增删查改" class="headerlink" title="增删查改"></a>增删查改</h3><p>但我们每次修改文件的时候，我们可以使用 git add 加上文件的名字，将文件加入版本库，然后再使用 git commit 提交修改。假设我们在版本库中创建了三个新的文件file1.txt，file2.txt，file3.txt，那我们我们可以使用以下的命令更新版本库：</p><pre><code>$ git add file1.txt file2.txt file3.txt$ git commit -m "Added three new files"</code></pre><p>除了使用第一行的方式添加多个文件，我们可以使用git add .（英文句号）将当前所有有变化的文件加入版本库：</p><pre><code>$ git add .</code></pre><h3 id="Git记录-log"><a href="#Git记录-log" class="headerlink" title="Git记录 (log)"></a>Git记录 (log)</h3><p>在git中，每一次提交修改(commit)，这条记录都会被保存起来。好比建大楼的时候，每个commit记录了盖楼需要添加和拿走的材料，这个施工过程都被记录下来了。而在git中，使用git log就能查看代码改动信息。</p><p>基于我们之前对版本库的改动，我们使用<code>git log</code>就能看的以下的信息，其中包含了commit ID、作者（修改者）、日期和修改备注：</p><pre><code>commit 2443b8c95bd2f426447b76b77ad5385a3d79a4ea (HEAD -&gt; master)Author: Enoch &lt;turingplanet@gmail.com&gt;Date:   Thu Oct 17 08:06:30 2019 -0700    Added three new filescommit f76e81f3c8e7c54dd917e9616da64ff3fde4fab9Author: Enoch &lt;turingplanet@gmail.com&gt;Date:   Mon Oct 14 09:44:19 2019 -0700    Modified the first two lines of new filecommit 2bbcd42eb3441375ae8f3c0b15d3f776302ad4feAuthor: Enoch &lt;turingplanet@gmail.com&gt;Date:   Mon Oct 14 09:32:28 2019 -0700    Added a new file</code></pre><p>如果这个时候我们在file1.txt的内部添加以下内容：</p><pre><code>new content</code></pre><p>然后我们再使用git status就能看到当前版本库中被修改的内容：</p><pre><code>On branch masterChanges not staged for commit:  (use "git add &lt;file&gt;..." to update what will be committed)  (use "git checkout -- &lt;file&gt;..." to discard changes in working directory)    modified:   file1.txtno changes added to commit (use "git add" and/or "git commit -a")</code></pre><p>那我们就先将此改动添加（add）并提交（commit）到版本库：</p><pre><code>$ git add file1.txt$ git commit -m "Modified file1"[master 0e84b3e] Modified file1 1 file changed, 1 insertion(+)</code></pre><p>这个时候我们再查看log，则会发现我们多了一条commit：</p><pre><code>commit 0e84b3e405630f1fc6ca9beb82cf5ca9ed38ea5a (HEAD -&gt; master)Author: Enoch &lt;walkerhaozheng@gmail.com&gt;Date:   Thu Oct 17 08:21:19 2019 -0700    Modified file1commit 2443b8c95bd2f426447b76b77ad5385a3d79a4eaAuthor: Enoch &lt;walkerhaozheng@gmail.com&gt;Date:   Thu Oct 17 08:06:30 2019 -0700    Added three new files...</code></pre><h3 id="Working-directory-Staging-area-Repository"><a href="#Working-directory-Staging-area-Repository" class="headerlink" title="Working directory, Staging area, Repository"></a>Working directory, Staging area, Repository</h3><p><img src="https://cdn.jsdelivr.net/gh/Tian-JQ/images/img/20200311160438.png" alt=""></p><p>为了帮助大家更好的理解工作区（working directory）、暂存区（staging directory）、和版本库（repository），我们可以对各个区域进行修改，然后通过git diff来查看他们之间的区别。</p><p>比如我们先给file2.txt添加以下的内容：</p><pre><code>new content in file2</code></pre><p>入行我们使用git diff来对比当前的工作区和上一次commit的版本库的区别：</p><pre><code>$ git diffdiff --git a/file2.txt b/file2.txtindex e69de29..de59346 100644--- a/file2.txt+++ b/file2.txt@@ -0,0 +1 @@+new content in file2</code></pre><p>如果这个时候我们使用add file2的修改，将当前的改动添加到暂存区，那么我们使用git diff后，会发现没有任何信息，这是因为我们的改动被转移到暂且区了。所以我们可以使用diff加上–cached来对比当前的暂存区和上一个commit的区别：</p><pre><code>$ git diff --cacheddiff --git a/file2.txt b/file2.txtindex e69de29..de59346 100644--- a/file2.txt+++ b/file2.txt@@ -0,0 +1 @@+new content in file2</code></pre><p>我们可以再改动一下file3.txt，在其中添加以下内容：</p><pre><code>new content in file3</code></pre><p>我们可以使用git diff HEAD来对比当前暂且区和工作区的区别：</p><pre><code>diff --git a/file2.txt b/file2.txtindex e69de29..de59346 100644--- a/file2.txt+++ b/file2.txt@@ -0,0 +1 @@+new content in file2diff --git a/file3.txt b/file3.txtindex e69de29..944ef83 100644--- a/file3.txt+++ b/file3.txt@@ -0,0 +1 @@+new content in file3</code></pre><p>这个时候我们将三个区间的内容进行对比，大家就能理解三个区间的关系了：</p><pre><code>$ git diffdiff --git a/file3.txt b/file3.txtindex e69de29..944ef83 100644--- a/file3.txt+++ b/file3.txt@@ -0,0 +1 @@+new content in file3$ git diff --cacheddiff --git a/file2.txt b/file2.txtindex e69de29..de59346 100644--- a/file2.txt+++ b/file2.txt@@ -0,0 +1 @@+new content in file2$ git diff HEADdiff --git a/file2.txt b/file2.txtindex e69de29..de59346 100644--- a/file2.txt+++ b/file2.txt@@ -0,0 +1 @@+new content in file2diff --git a/file3.txt b/file3.txtindex e69de29..944ef83 100644--- a/file3.txt+++ b/file3.txt@@ -0,0 +1 @@+new content in file3</code></pre><p>但我们确定要修改的内容后，我们可以直接add并commit，将所有的修改加到暂存区后并提交到版本库：</p><pre><code>$ git add .$ git commit -m "Modified file2 and file3"[master 0aef827] Modified file2 and file3 2 files changed, 2 insertions(+)</code></pre><h3 id="时光穿越机-checkout-amp-reset"><a href="#时光穿越机-checkout-amp-reset" class="headerlink" title="时光穿越机 (checkout &amp; reset)"></a>时光穿越机 (checkout &amp; reset)</h3><p>有时候我们对一些文件做了改动，并加到暂存区，但是又后悔了，这些操作在 git 中也能实现。比如，我们继续改动file1.txt，在其中添加一行的内容：</p><pre><code>new contentmore content</code></pre><p>然后我们把file1.txt加入暂存区，如果我们想要反悔，可以直接使用 git reset 把 file1.txt 从暂存区拉回到工作区，然后对文件做相应的修改后再add：</p><pre><code>$ git add file1.txt$ git status -s M  file1.txt # working directory$ git reset file1.txtUnstaged changes after reset:M    file1.txt$ git status -s  M file1.txt # staging area</code></pre><p>然后我们把file1.txt中第一行new content删除，只剩下more content之后，直接add然后commit：</p><pre><code>$ git add file1.txt$ git commit -m "Added more content in file1"</code></pre><p>接下来我们来了解git中的checkout，checkout可以帮助我们让当前的工作区回到特定的某个commit，比如我们使用git log查看过去的一些commit：</p><pre><code>$ git log --oneline5c10f81 (HEAD -&gt; master) Added more content in file10aef827 Modified file2 and file30e84b3e Modified file12443b8c Added three new filesf76e81f Modified the first two lines of new file2bbcd42 Added a new file</code></pre><p>然后我们使用checkout回到 0aef827 这个commit，可以发现 file1.txt 的内容也变回了，因为在那个时候 file1 的内容并没有被改动，所以我们用了git log之后并没有 Added more content in file1 这个commit：</p><pre><code>$ git checkout 0aef827Note: checking out '0aef827'.....$ cat file1.txtnew content$ git log --oneline0aef827 (HEAD) Modified file2 and file30e84b3e Modified file12443b8c Added three new filesf76e81f Modified the first two lines of new file2bbcd42 Added a new file</code></pre><p>若想要在从过去回到现在，我们可以使用 git checkout master：</p><pre><code>$ git checkout master$ cat file1.txtmore content</code></pre><p>我们可以通过下面的图片对checkout进行理解：</p><p><img src="https://cdn.jsdelivr.net/gh/Tian-JQ/images/img/20200311163925.png" alt=""></p><p>这里的HEAD其实是一个指针，可以让我们知道当前处于哪一个commit。如果我们想要让HEAD彻底回到某一个commit，我们可以使用在reset后面加上–hard参数：</p><pre><code>$ git reset --hard HEAD # 当前add的工作全部消失，回到上一次commit HEAD is now at 5c10f81 Added more content in file1$ git log --oneline5c10f81 (HEAD -&gt; master) Added more content in file10aef827 Modified file2 and file30e84b3e Modified file1...$ git reset --hard HEAD^ # 回到当前master的上一个commit:c0aef827$ git reset --hard 0e84b3e # 回到具体的某一个commit$ git log --oneline 0e84b3e (HEAD -&gt; master) Modified file12443b8c Added three new filesf76e81f Modified the first two lines of new file2bbcd42 Added a new file</code></pre><p>我们的 Modified file2 and file3 彻底消失了！如果我们想要重新挽回改动，可以使用 git reflog 查看最近做的所有的 HEAD 的改动，并使用 reset 重回到想要退回的 commit：</p><pre><code>$ git reflog0e84b3e (HEAD -&gt; master) HEAD@{0}: reset: moving to 0e84b3e0aef827 HEAD@{1}: reset: moving to HEAD^5c10f81 HEAD@{2}: reset: moving to HEAD5c10f81 HEAD@{3}: checkout: moving from 0aef8274ff89375120cbd38be7e4a494aa19f0e7 to master0aef827 HEAD@{4}: checkout: moving from master to 0aef8275c10f81 HEAD@{5}: commit: Added more content in file1...$ git reset --hard 5c10f81</code></pre><p>通过查看 file1.txt 的内容，确定一下我们时空穿越成功：</p><pre><code>$ git cat file1.txtmore content</code></pre><h2 id="分支、合并、标签管理"><a href="#分支、合并、标签管理" class="headerlink" title="分支、合并、标签管理"></a>分支、合并、标签管理</h2><p>分支是什么？我们可以简单地把每个分支理解为一个平行宇宙，每个平行宇宙之间的变化不会影响到其他的宇宙，只有我们强行合并的时候，平行宇宙之间的改动才会互相影响。</p><p>那为什么我们需要分支呢？在开发软件的时候，我们经常需要同时开发不同的版本，比如版本1是稳定版本，而版本2需要开发新的功能A，版本3需要开发新的功能B，如果同时在一个分支中开发三个版本，那会乱套的。所以我们需要创建两个单独的分支给版本2和版本3进行开发，当各个版本的功能完善后，我们就可以将新的改变合并到稳定版本中，这样我们的开发流程即分工明确，也不会出错。</p><p><img src="https://cdn.jsdelivr.net/gh/Tian-JQ/images/img/20200311160859.png" alt=""></p><h3 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支"></a>创建分支</h3><p>在我们初始化一个版本库的时候，Git会默认创建一个master分支，提交也都默认提交到master中。我们有个HEAD指针，这个指针指明我们当前在哪个分支的commit中工作，如果我们切换到别的分支，我们的HEAD也会转移指向。</p><p><img src="https://cdn.jsdelivr.net/gh/Tian-JQ/images/img/20200311160938.png" alt=""></p><p>如果要创建分支，我们直接使用<code>git branch &lt;branch_name&gt;</code>即可，我们先创建一个分支dev，然后查看所有分支：</p><pre><code>$ git branch dev $ git branch  dev* master</code></pre><p>如果我们想要将 HEAD 切换到 dev 分支，我们可以使用 checkout：</p><pre><code>$ git checkout dev Switched to branch 'dev'$ git branch* dev  master</code></pre><p>使用 <code>git checkout -b &lt;branch_name&gt;</code>，能直接创建并切换到新的分支：</p><pre><code>$ git checkout -b devSwitched to a new branch 'dev'</code></pre><p>dev 分支中的文件和 master 的文件是一样的，当 HEAD 指向 dev 的时候，我们对文件夹中的修改是不会影响到 master 分支的。我们把 file1.txt 的内容改为 more content in dev branch，然后提交：</p><pre><code>$ git commit -am "Modified file1 in dev branch" # -am参数: 添加所有改变，然后提交</code></pre><h3 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h3><p>如果要把 dev 分支中的更新推送到 master 中，我们需要切换到 master，然后再将 dev 的更新合并过来：</p><pre><code>$ git checkout masterSwitched to branch 'master'$ git merge devUpdating 5c10f81..323b3ebFast-forward file1.txt | 2 +- 1 file changed, 1 insertion(+), 1 deletion(-)$ git log --oneline --graph* 323b3eb (HEAD -&gt; master, dev) Modified file1 in dev branch* 5c10f81 Added more content in file1* 0aef827 Modified file2 and file3...</code></pre><p>默认的 merge 是使用 Fast forward 方式，并不会保存分支图案，如果想要 log 保存分支的信息，我们在merge的时候需要添加 -no-ff 参数更新comment：</p><pre><code>$ git reset --hard HEAD^ $ git merge --no-ff -m "Add merge info" devMerge made by the 'recursive' strategy. file1.txt | 2 +- 1 file changed, 1 insertion(+), 1 deletion(-)$ git log --oneline --graph*   16572d5 (HEAD -&gt; master) Add merge info|\  | * 323b3eb (dev) Modified file1 in dev branch |/  * 5c10f81 Added more content in file1...</code></pre><h3 id="分支冲突"><a href="#分支冲突" class="headerlink" title="分支冲突"></a>分支冲突</h3><p>在多人同时开发不同分支的时候，分支冲突是很常见的现象。比如程序员A在master中对file1进行修改并提交，而程序员B在dev分支中对file1也进行了修改并提交，那么在我们把dev合并到master的时候，我们就会发现冲突。</p><p>如果程序员A在file1中添加新的内容 new content in master，然后程序员B在file2中添加新的内容new content in dev，那么当我们查看各个分支log的时候，则会有以下的信息</p><pre><code># master 的 logf844b75 (HEAD -&gt; master) new content in masterdda9338 Add merge info323b3eb Modified file1 in dev branch...# dev 的 logaa1a832 (HEAD -&gt; dev) new content in dev323b3eb Modified file1 in dev branch5c10f81 Added more content in file1...</code></pre><p>然后我们尝试把dev合并到master，就会输出冲突的信息：</p><pre><code>$ git branch   dev* master$ git merge devAuto-merging file1.txtCONFLICT (content): Merge conflict in file1.txtAutomatic merge failed; fix conflicts and then commit the result.</code></pre><p>当git发现file1在master和dev上的版本不同时，就会提示冲突，我们只要打开file1，就会看到git给文件的标记：</p><pre><code># file1.txtmore content in dev branch&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEADnew content in master=======new content in dev&gt;&gt;&gt;&gt;&gt;&gt;&gt; dev        </code></pre><p>我们<strong>手动合并两者的不同，然后提交就可以了</strong>。</p><pre><code># file1.txtmore content in dev branchmerged content from master and dev$ git commit -am "solve conflict""[master f0687a0] solve confict</code></pre><p>这时候我们再看看master的log：</p><pre><code>$ git log --oneline --graph*   f0687a0 (HEAD -&gt; master) solve confict|\  | * aa1a832 (dev) new content in dev* | f844b75 new content in master* |   dda9338 Add merge info|\ \  | |/  | * 323b3eb Modified file1 in dev branch|/  * 5c10f81 Added more content in file1...</code></pre><h3 id="标签管理"><a href="#标签管理" class="headerlink" title="标签管理"></a>标签管理</h3><p>标签是我们对commit设置的别名，可以帮助我们对commit进行更好的管理，如果你的老板叫你发布一个版本，然后告诉你commit id是f844b3…，这样的交流是容易出错的，因为id号又长又臭，很难管理。如果我们使用标签，比如每个版本都有专属的版本号，比如v2.0之类的，这样我们发布和管理commit就更方便了。</p><p>如果想要创建标签，只要切换到想要打标签的分支上，使用<code>git tag &lt;name&gt;</code>就好了：</p><pre><code>$ git branch  dev* master$ git tag v1.0 # 新的标签$ git log --onelinef0687a0 (HEAD -&gt; master, tag: v1.0) solve confictaa1a832 (dev) new content in devf844b75 new content in master...</code></pre><p>tag默认情况下是给当前分支的最新commit打标签，如果想要给旧的commit打上标签，使用<code>git tag &lt;tag_name&gt; &lt;commit_id&gt;</code>就好了：</p><pre><code>$ git tag v0.9 f844b75$ git log --onelinef0687a0 (HEAD -&gt; master, tag: v1.0) solve confictaa1a832 (dev) new content in devf844b75 (tag: v0.9) new content in master...</code></pre><p>如果这个时候我们想要回到过去的版本，只需要使用标签名就可以了：</p><pre><code>$ git checkout v0.9$ git log --onelinef844b75 (HEAD, tag: v0.9) new content in masterdda9338 Add merge info</code></pre><p>注意：标签是和commit挂钩的，如果这个commit同时出现在多个分支上，那么这些分支都能查看此标签。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><pre><code>$ git branch # 查看当前版本库所有分支$ git branch &lt;name&gt; # 创建新的分支$ git checkout &lt;name&gt; or git switch &lt;name&gt; # 切换分支$ git checkout -b &lt;name&gt; or git switch -c &lt;name&gt; # 创建并切换至新的分支$ git merge &lt;name&gt; # 将name分支合并至当前分支$ git log --oneline --graph # 查看具体log信息$ git branch -d &lt;name&gt; # 删除分支$ git tag &lt;tag_name&gt; # 为当前的commit创建新的标签$ git tag -d &lt;tag_name&gt; # 删除标签</code></pre><h2 id="远程仓库GitHub"><a href="#远程仓库GitHub" class="headerlink" title="远程仓库GitHub"></a>远程仓库GitHub</h2><p>Git是分布式版本控制系统，同一个Git仓库，可以分布到不同的机器上。通常情况下，我们在一台服务器上部署一个主版本库，然后其他的机器就从此服务器上下载版本库，将版本库更新后，再将本地的版本库推送到主服务器，同时更新服务上的版本库，达到远程操作版本库的效果。</p><p>可是自己搭建服务器很麻烦，而且也不安全，多亏了GitHub这个免费的版本库托管网站，我们只要注册一个账户，就能创建属于自己的远程仓库。</p><h3 id="添加远程库GitHub"><a href="#添加远程库GitHub" class="headerlink" title="添加远程库GitHub"></a>添加远程库GitHub</h3><p>在<a href="https://github.com/" target="_blank" rel="noopener">github</a>上注册一个账户，然后即可创建一个新的网上版本库：</p><img src="https://cdn.jsdelivr.net/gh/Tian-JQ/images/img/20200311162308.png" style="zoom:67%;"><h3 id="远程数据库克隆"><a href="#远程数据库克隆" class="headerlink" title="远程数据库克隆"></a>远程数据库克隆</h3><p>如果想要将别人的网上版本库下载到自己的电脑中，我们只需要找到版本库的地址，然后使用git clone命令克隆就可以了，非常方便。</p><p>这边作为演示，提供用Python编写的图像处理器供大家下载。首先登入gitHub版本库的地址<a href="https://github.com/turingplanet/digital-image-processor，点击绿色的框复制repo的地址。" target="_blank" rel="noopener">https://github.com/turingplanet/digital-image-processor，点击绿色的框复制repo的地址。</a></p><img src="https://cdn.jsdelivr.net/gh/Tian-JQ/images/img/20200311162550.png"><p>然后在本地电脑中使用git clone复制版本库：</p><pre><code>$ git clone https://github.com/turingplanet/digital-image-processor.git</code></pre><p>最后进入版本库，直接运行程序即可：</p><pre><code>$ cd digital-image-processor$ python3 gui.py</code></pre><p>然后就可以使用一个简易的图像处理器啦~</p><p><img src="https://cdn.jsdelivr.net/gh/Tian-JQ/images/img/20200311163025.png" alt=""></p><p>GitHub上有无数的开源程序供大家下载，都是使用相同的方法，现在大家可以去尽情探索了~</p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><pre><code>$ git remote add &lt;remote_name&gt; &lt;remote_address&gt; # 添加远程仓库$ git push -u &lt;remote_name&gt; master # 推送本地仓库至远程仓库$ git clone &lt;remote_address&gt; # 克隆远程仓库</code></pre><blockquote><p>特别鸣谢</p><p>参考网址</p><p><a href="https://haozhengio.com/git和github教程/" target="_blank" rel="noopener">https://haozhengio.com/git%E5%92%8Cgithub%E6%95%99%E7%A8%8B/</a></p></blockquote><h2 id="如何提交代码到Github项目"><a href="#如何提交代码到Github项目" class="headerlink" title="如何提交代码到Github项目"></a>如何提交代码到Github项目</h2><ol><li><p>从源仓库OS-ABC/Kcoin-Golang 中把代码Fork 到自己的Github 账号里。</p></li><li><p>在自己Fork 的仓库中获取该仓库的Clone 地址。</p><p> <img src="https://cdn.jsdelivr.net/gh/Tian-JQ/images/img/20200311161013.png" alt=""></p></li><li><p>使用git 命令将仓库Clone 到本地。</p><p>命令：git clone &lt;第二步中复制的仓库地址&gt;</p><p><img src="https://cdn.jsdelivr.net/gh/Tian-JQ/images/img/20200310004716.png" alt=""></p></li><li><p>进入到Clone 下来的仓库目录中</p><p> <img src="https://cdn.jsdelivr.net/gh/Tian-JQ/images/img/20200310005103.png" alt=""></p></li><li><p>把源仓库（OS-ABC/Kcoin-Golang）加入到远程仓库中，方便以后拉取更新</p><p>​    (1) 复制源仓库的地址</p><img src="https://cdn.jsdelivr.net/gh/Tian-JQ/images/img/20200310005200.png" style="zoom:50%;"><p>​    (2) 在git 中把源仓库地址加入到远程仓库中</p><p><img src="https://cdn.jsdelivr.net/gh/Tian-JQ/images/img/20200311161046.png" alt=""></p><p>​    (3) 查看一下当前远程仓库的信息</p><p><img src="https://cdn.jsdelivr.net/gh/Tian-JQ/images/img/20200311161109.png" alt=""></p></li><li><p>切换到dev 分支</p><p>如果使用的是windows 下的git bash，可以看到最后蓝色部分指的是当前分支（master）。</p><p><img src="https://cdn.jsdelivr.net/gh/Tian-JQ/images/img/20200311161330.png" alt=""></p><p>也可以使用git 命令查看当前的分支情况。</p><p>命令：git branch -a</p><p><img src="https://cdn.jsdelivr.net/gh/Tian-JQ/images/img/20200310005345.png" alt=""></p><p>红色的是远程仓库的分支信息，第一行前面有“*”的是当前分支。<br>下面我们要在本地新建一个dev 分支，并让这个dev 分支和origin 仓库的dev 分支拥有<br>相同历史。<br>命令：git checkout -b dev origin/dev</p><p><img src="https://cdn.jsdelivr.net/gh/Tian-JQ/images/img/20200311161402.png" alt=""></p><p>执行完这条命令后，可以看到当前分支已经变为dev 了:</p><p><img src="https://cdn.jsdelivr.net/gh/Tian-JQ/images/img/20200311161424.png" alt=""></p></li><li><p>拉取 upstream 上dev 分支的更新</p><p>命令：git pull upstream dev</p><p><img src="https://cdn.jsdelivr.net/gh/Tian-JQ/images/img/20200311161447.png" alt=""></p></li><li><p>修改三连</p><p> （1）git add .<br> （2）git commit -m ‘this is a commit’<br> （3）git push origin dev</p></li><li><p>在github 页面上提PR</p><p>首先进入自己fork 下来的仓库（origin），点击new pull request。<br>然后要特别注意下面的四个选择框</p><p><img src="https://cdn.jsdelivr.net/gh/Tian-JQ/images/img/20200311164134.png" alt=""></p><p>按照中间的箭头方向，一定要从自己fork 的仓库（origin）的dev 分支到源仓库<br>（upstream）的dev 分支，如果提到了upstream的master 分支上去，就会出现pr 中有<br>一长串的commit 的情况。</p></li></ol><p>   最后在提pr 的页面看一看文件改动对比，看看是不是都是自己想改的，然后填写好pr<br>   描述创建pr 就可以了。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> github </tag>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>程序员素养</title>
      <link href="/blog/2020/02/09/cheng-xu-yuan-su-yang/"/>
      <url>/blog/2020/02/09/cheng-xu-yuan-su-yang/</url>
      
        <content type="html"><![CDATA[<h2 id="程序员素养"><a href="#程序员素养" class="headerlink" title="程序员素养"></a>程序员素养</h2><h3 id="专业基础知识"><a href="#专业基础知识" class="headerlink" title="专业基础知识"></a>专业基础知识</h3><ul><li><p>代码</p><p>掌握至少一门语言，会编程，写代码解决问题，也要有手写代码的能力。</p><p>问：写一个坦克大栈模型？</p></li><li><p>算法+数据结构</p><p>算法是解决问题的基本思想。</p><p>问：100亿数据中选出10个最小数据？</p></li><li><p>问题处理</p><p>处理问题是最终目的。</p><p>问：一个用户页面出现502错误，应该怎么办？（了解问题，最好能够问题复现，找到问题原因）</p></li><li><p>论文</p><p>写论文、看论文是深度学习的必要方式。</p></li></ul><h3 id="逻辑分析能力"><a href="#逻辑分析能力" class="headerlink" title="逻辑分析能力"></a>逻辑分析能力</h3><ul><li><p>逻辑分析+模型构建</p><p>很多复杂问题必须具备好的逻辑分析能力。</p></li></ul><h3 id="视野"><a href="#视野" class="headerlink" title="视野"></a>视野</h3><p>了解行业趋势：</p><p>选择很重要！</p><p><strong>关键字</strong>：<code>前沿领域</code>、<code>学习能力强</code>、<code>兴趣爱好</code>、<code>前沿产业</code></p><p>未来信息产业：智能时代；</p><p>建议看科普类，不一定爆发，但是不然趋势；</p><p>1：PC时代-PC互联网-移动互联网-产业互联网-万物互联网  （规模-&gt;流量-&gt;数据）</p><p>玛丽·米克尔（Mary Meeker） :互联网女王    2019年发布了第24版互联网趋势报告    </p><p>2：云（云化）：横向扩展资源        动态调整存储        微服务（实现小模块功能）    </p><p>3:软件工程方法：     可控、质量-&gt;速度-&gt;？（数据）    </p><p>新兴技术和人工智能技术的发展趋势（Gartner:趋势报告）</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 互联网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 程序员 </tag>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Google Chrome+IDM</title>
      <link href="/blog/2020/02/09/google-chrome-idm/"/>
      <url>/blog/2020/02/09/google-chrome-idm/</url>
      
        <content type="html"><![CDATA[<h2 id="谷歌浏览器"><a href="#谷歌浏览器" class="headerlink" title="谷歌浏览器"></a>谷歌浏览器</h2><h3 id="为何推荐谷歌浏览器："><a href="#为何推荐谷歌浏览器：" class="headerlink" title="为何推荐谷歌浏览器："></a><strong>为何推荐谷歌浏览器：</strong></h3><p>炫酷 DIY设计、功能强大 依附于强大的插件扩展、兼容性强、操作人性化……</p><h3 id="设置推荐"><a href="#设置推荐" class="headerlink" title="设置推荐"></a><strong>设置推荐</strong></h3><p>显示书签页</p><img src="https://cdn.jsdelivr.net/gh/Tian-JQ/images/img/chromo设置1.png" style="zoom: 50%;"><h2 id="插件推荐"><a href="#插件推荐" class="headerlink" title="插件推荐"></a>插件推荐</h2><h3 id="Infinity"><a href="#Infinity" class="headerlink" title="Infinity"></a><a href="https://cn.infinitynewtab.com/" target="_blank" rel="noopener">Infinity</a></h3><h3 id="Tampermonkey"><a href="#Tampermonkey" class="headerlink" title="Tampermonkey"></a><a href="http://www.tampermonkey.net/" target="_blank" rel="noopener">Tampermonkey</a></h3><h2 id="IDM"><a href="#IDM" class="headerlink" title="IDM"></a>IDM</h2><p>IDM安装使用可参考：<a href="https://mp.weixin.qq.com/s?__biz=MzU4MTg2MzYwMg==&amp;mid=2247492148&amp;idx=1&amp;sn=30b920791711b1cf07237abd9d93782f&amp;chksm=fd43b3e9ca343affb75907a4ea953ed16c07d7859e1f4c358a39200c1f53dc06a5fd5ea080fb&amp;mpshare=1&amp;scene=1&amp;srcid=0209Ve5UC5l57e8DmGxyCwuB&amp;sharer_sharetime=1581233965437&amp;sharer_shareid=4f4f6fb45b6bf937a37965b8a87182b9&amp;key=bb131354e4783867f624481f21355e127d963014da48326d55c177d5675e801cfeb87100ef41f8c203e985bfb138e4a2e10db6b6c9886cc4882f09afa41ed0a82322d2f3be1eb96db88a9a1d58323bb3&amp;ascene=1&amp;uin=MjY5ODU3NzYwNQ%3D%3D&amp;devicetype=Windows+10&amp;version=6208006f&amp;lang=zh_CN&amp;exportkey=Aw7Qbbk47Sfbg6YZs9By2AI%3D&amp;pass_ticket=C0iD2%2F1OliHVKkBarOrE%2B8Z%2BeftKHICL6PX2srIZvy9lwKeagTnL4pOsdVZtW8u%2B" target="_blank" rel="noopener">IDM</a></p><p>Chromo搭载IDM下载，可高速下载网站资源</p><p>配合Tampermonkey+百度云脚本，即可利用IDM高速下载百度云资源。</p><p><a href="https://greasyfork.org/zh-CN/scripts" target="_blank" rel="noopener">Tampermonkey脚本下载网址</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Google </tag>
            
            <tag> Chrome </tag>
            
            <tag> IDM </tag>
            
            <tag> 下载器 </tag>
            
            <tag> 浏览器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>授人以渔之学习</title>
      <link href="/blog/2020/02/08/shou-ren-yi-yu-zhi-xue-xi/"/>
      <url>/blog/2020/02/08/shou-ren-yi-yu-zhi-xue-xi/</url>
      
        <content type="html"><![CDATA[<h2 id="学习–搜索方法"><a href="#学习–搜索方法" class="headerlink" title="学习–搜索方法"></a>学习–搜索方法</h2><h3 id="微信搜一搜"><a href="#微信搜一搜" class="headerlink" title="微信搜一搜"></a>微信搜一搜</h3><p>使用微信搜一搜可以捕捉到相关文章、公众号和资源，而且基本上没有广告。</p><p>这是我手机端搜索最常用的方法，相对于只能查找到相关网页、带有广告的浏览器搜索，微信搜索显得更人性化。</p><p>值得提醒的是，很多破解软件可通过此方法搜到。</p><p><strong>方法1</strong></p><img src="https://cdn.jsdelivr.net/gh/Tian-JQ/images/img/搜一搜1.jpg" style="zoom: 25%;"><p><strong>方法2</strong></p><img src="https://cdn.jsdelivr.net/gh/Tian-JQ/images/img/搜一搜2.jpg" style="zoom:25%;"><h3 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h3><p>浏览器是搜索最普遍的方法，电脑端推荐谷歌浏览器。</p><hr><h2 id="学习–网站推荐"><a href="#学习–网站推荐" class="headerlink" title="学习–网站推荐"></a>学习–网站推荐</h2><h3 id="bilibili"><a href="#bilibili" class="headerlink" title="bilibili"></a><a href="https://www.bilibili.com/" target="_blank" rel="noopener">bilibili</a></h3><p>哔哩哔哩网站看似一个动漫网站，实际上拥有大量教学资源，直接关键字搜索即可出结果，很多需要购买才能看的视频这里都有。</p><h3 id="菜鸟教程"><a href="#菜鸟教程" class="headerlink" title="菜鸟教程"></a><a href="https://www.runoob.com/" target="_blank" rel="noopener">菜鸟教程</a></h3><p>学习计算机很好的教程网站，内容丰富。</p><h3 id="博客"><a href="#博客" class="headerlink" title="博客"></a>博客</h3><p>如博客园、简书、新浪等，内含很多优质博客可以学习。</p><p>如果想搭建自己的博客，我写了一篇Hexo+Github搭建个人博客的<a href="https://tian-jq.github.io/2020/01/31/hexo-github-da-jian-ge-ren-bo-ke/" target="_blank" rel="noopener">教程</a></p><h3 id="知乎"><a href="#知乎" class="headerlink" title="知乎"></a><a href="https://www.zhihu.com/" target="_blank" rel="noopener">知乎</a></h3><p>聚集很多专业人士的文章。</p><h3 id="Github"><a href="#Github" class="headerlink" title="Github"></a><a href="https://github.com/" target="_blank" rel="noopener">Github</a></h3><p>Github 拥有海内外开源项目，此外，可用于资源（学习资料、教程、软件等。。。）搜索，这是另一片天，值得摸索。</p><h3 id="Leetcode"><a href="#Leetcode" class="headerlink" title="Leetcode"></a><a href="https://leetcode-cn.com/" target="_blank" rel="noopener">Leetcode</a></h3><p>算法刷题必备，有国行版和英文版。</p><p>国行版速度更快，对于英语不好的朋友显得更加友好；</p><p>英文版有国内外朋友的算法解题推荐，参考更加宽广，其次练题的过程可以锻炼英语，网站运行速度没有国行版快。</p><p>有相应手机APP，方便离线学习。</p><hr><h2 id="学习–软件推荐"><a href="#学习–软件推荐" class="headerlink" title="学习–软件推荐"></a>学习–软件推荐</h2><h3 id="有道云笔记"><a href="#有道云笔记" class="headerlink" title="有道云笔记"></a><a href="http://note.youdao.com/index.html" target="_blank" rel="noopener">有道云笔记</a></h3><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>笔记记录+网页收藏+文档管理</p><p>计划安排+日记+会议记录</p><p>。。。。。。</p><h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><h5 id="文件夹式管理"><a href="#文件夹式管理" class="headerlink" title="文件夹式管理"></a>文件夹式管理</h5><p>方便高效。</p><h5 id="文档管理，高效记录"><a href="#文档管理，高效记录" class="headerlink" title="文档管理，高效记录"></a>文档管理，高效记录</h5><p>文字/图片/语音/手写/OCR/Markdown等多种形式，随时随地记录你的精彩。全面兼容office、PDF等办公常用文档，无需下载即可查看编辑。</p><h5 id="收藏，精彩不错过"><a href="#收藏，精彩不错过" class="headerlink" title="收藏，精彩不错过"></a>收藏，精彩不错过</h5><p>支持微信、微博、链接收藏和网页剪报等多种形式，优秀内容一键保存永不丢失，搭建属于你的知识体系。</p><h5 id="OCR扫描，快捷准确"><a href="#OCR扫描，快捷准确" class="headerlink" title="OCR扫描，快捷准确"></a>OCR扫描，快捷准确</h5><p>满足文档、手写、名片等多场景需求，特别支持PDF转Wo</p><p>rd功能，无需繁琐操作，一键轻松搞定。</p><h5 id="多端同步，随时查看"><a href="#多端同步，随时查看" class="headerlink" title="多端同步，随时查看"></a>多端同步，随时查看</h5><p>PC/iPhone/Android/web/iPad/Mac/Wap……随时备份，云端同步，重要资料还可加密保存。 无惧断网/断电困扰，任何情况下都能轻松查阅。</p><h5 id="轻松分享，协同处理"><a href="#轻松分享，协同处理" class="headerlink" title="轻松分享，协同处理"></a>轻松分享，协同处理</h5><p>文档一键分享微信、QQ、微博、邮件等平台。团队协作修改，实时处理更高效。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> 学习方法 </tag>
            
            <tag> 编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>蝙蝠和人类</title>
      <link href="/blog/2020/02/06/bian-fu-he-ren-lei/"/>
      <url>/blog/2020/02/06/bian-fu-he-ren-lei/</url>
      
        <content type="html"><![CDATA[<h4 id="蝙蝠传说"><a href="#蝙蝠传说" class="headerlink" title="蝙蝠传说"></a><strong>蝙蝠传说</strong></h4><p>传说，蝙蝠是老鼠同类，因老鼠偷吃盐而进化出翅膀；传说，蝙蝠是黑暗中的鸟，在月黑风高时飞行；传说，蝙蝠是夜间的吸血鬼，是恐怖和邪恶的化身……</p><p>事实上，蝙蝠不是老鼠同类，但具有极其相似的样貌，尖嘴细牙，小眼长耳，发出的叫声也无法分辨。</p><p>蝙蝠会飞，而被误认为是鸟类，其实除了飞之外，其他特征皆不同于鸟类。蝙蝠翅膀并非羽毛，而是皮肤生成的膜；鸟嘴是尖状，没有牙齿；鸟以下蛋的方式生子，蝙蝠却是胎生哺乳。生物学将蝙蝠定义为哺乳动物中的翼手目类，老鼠属于哺乳动物中的啮齿类。</p><p>蝙蝠因在夜间活动，咧嘴恐怖，因而代表了邪恶的吸血鬼。然而，在上千种蝙蝠中，只有两三种会吸血，而且都生活在遥远的美洲，主要取食对象是牲畜类。大多数蝙蝠主要以果实、花蜜，或者捕食昆虫为主。</p><p>蝙蝠传说，同时说明蝙蝠起源历史悠久，分布极广，和人类有着千丝万缕的关系，西方还有以蝙蝠侠为主角的影视作品。</p><h4 id="人吃蝙蝠"><a href="#人吃蝙蝠" class="headerlink" title="人吃蝙蝠"></a><strong>人吃蝙蝠</strong></h4><p><img src="https://cdn.jsdelivr.net/gh/Tian-JQ/images/img/%E8%9D%99%E8%9D%A02.png" alt=""></p><p>总有人自诩自己吃过很多野味，引以为豪；总有人觉得吃得起野生动物是面子和身份的展示；总有人觉得，桌子上的稀有肉类就是山珍海味。这些人有形无形中吃了很多蝙蝠。有人直接吃蝙蝠肉，喝蝙蝠汤，有人间接吃蝙蝠，因为他们吃了果子狸、蛇、野猫和其他吃了蝙蝠肉的动物。</p><p>与其说蝙蝠的天敌是蛇，不如说是人类，几乎所有野生动物的天敌都有人的参与。</p><p>甚至有人吃野生动物作视频直播，有将野味作为热卖主菜的餐馆，以此谋取利益。“没有买卖，就没有杀害”，有人消费，自然就尽是杀害。很多野生动物和蝙蝠一样没有逃脱被人捕杀的厄运。</p><h4 id="“蝙蝠吃人”"><a href="#“蝙蝠吃人”" class="headerlink" title="“蝙蝠吃人”"></a><strong>“蝙蝠吃人”</strong></h4><p>人吃蝙蝠，祸从口出，错误的行为终将带来灾难。人吃蝙蝠的同时，亦不想蝙蝠也会“吃人”。</p><p>埃博拉病毒，大量学者认为最初来源是蝙蝠，导致非洲部分地区尸横遍野，直接死亡人数上万；SARS（非典）病毒最后证实来源于蝙蝠，通过果子狸间接传染给人类；此外，很多禽流感，病菌感染，都直接或间接来源于野生动物。</p><p>新型冠状病毒爆发，全国陷入紧张状态，病毒来源可能也是蝙蝠。无论病毒来源是不是蝙蝠，都印证了“蝙蝠吃人”的后果，而罪魁祸首就是吃野生动物的人们。</p><p>蝙蝠替所有野生动物给人类敲响警钟。</p><h4 id="生命共同体"><a href="#生命共同体" class="headerlink" title="生命共同体"></a><strong>生命共同体</strong></h4><p>蝙蝠有5000万年进化史，漫长的进化史使它拥有“百毒不侵”的免疫系统，因此，身上携带超过100多种致死性病毒。其所带病毒导致人类遭受一次次瘟疫，付出巨大代价。但究其原因，不是蝙蝠入侵人类，而是部分人变得贪婪和罪恶，是人们破坏了生态平衡，无休止地滥用资源，捕杀野生动物……</p><p>尽管蝙蝠浑身是毒，但几乎没有过蝙蝠袭击人类的事件。相反，蝙蝠以昆虫为食，具有控制蚊子和农业害虫数量、植物授粉和种子传播等积极作用。此外，通过对蝙蝠的仿生研究，促进了人类医疗技术和雷达技术的发展。</p><p><img src="https://cdn.jsdelivr.net/gh/Tian-JQ/images/img/%E8%9D%99%E8%9D%A03.png" alt=""></p><p>人与自然是不可分割的生命共同体。蝙蝠代表的是所有野生动物，甚至整个大自然，只有人们爱护动物，善待自然，自然才会善待人类。否则，仅仅一次病毒传播就可让无数人付出生命的代价。</p><p><img src="https://cdn.jsdelivr.net/gh/Tian-JQ/images/img/095786e945407bf.jpg" alt=""></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 文章 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文章 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL基础</title>
      <link href="/blog/2020/02/01/mysql-ji-chu/"/>
      <url>/blog/2020/02/01/mysql-ji-chu/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL学习笔记"><a href="#MySQL学习笔记" class="headerlink" title="MySQL学习笔记"></a>MySQL学习笔记</h1><h2 id="登录和退出MySQL服务器"><a href="#登录和退出MySQL服务器" class="headerlink" title="登录和退出MySQL服务器"></a>登录和退出MySQL服务器</h2><pre><code># 登录MySQL$ mysql -u root -p12345612# 退出MySQL数据库服务器exit;</code></pre><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><pre><code>-- 显示所有数据库show databases;-- 创建数据库CREATE DATABASE test;-- 切换数据库use test;-- 显示数据库中的所有表show tables;-- 创建数据表CREATE TABLE pet (    name VARCHAR(20),    owner VARCHAR(20),    species VARCHAR(20),    sex CHAR(1),    birth DATE,    death DATE);-- 查看数据表结构-- describe pet;desc pet;-- 查询表SELECT * from pet;-- 更改表名ALTER TABLE &lt;表名1&gt; RENAME TO &lt;表名2&gt;;-- 插入数据INSERT INTO pet VALUES ('puffball', 'Diane', 'hamster', 'f', '1990-03-30', NULL);-- 修改数据UPDATE pet SET name = 'squirrel' where owner = 'Diane';-- 删除数据DELETE FROM pet where name = 'squirrel';-- 删除表DROP TABLE myorder;</code></pre><h2 id="建表约束"><a href="#建表约束" class="headerlink" title="建表约束"></a>建表约束</h2><h3 id="主键约束"><a href="#主键约束" class="headerlink" title="主键约束"></a>主键约束</h3><pre><code>-- 主键约束-- 使某个字段不重复且不得为空，确保表内所有数据的唯一性。CREATE TABLE user (    id INT PRIMARY KEY,    name VARCHAR(20));-- 联合主键-- 联合主键中的每个字段都不能为空，并且加起来不能和已设置的联合主键重复。CREATE TABLE user (    id INT,    name VARCHAR(20),    password VARCHAR(20),    PRIMARY KEY(id, name));-- 自增约束-- 自增约束的主键由系统自动递增分配。CREATE TABLE user (    id INT PRIMARY KEY AUTO_INCREMENT,    name VARCHAR(20));-- 添加主键约束-- 如果忘记设置主键，还可以通过SQL语句设置（两种方式）：ALTER TABLE user ADD PRIMARY KEY(id);ALTER TABLE user MODIFY id INT PRIMARY KEY;-- 删除主键ALTER TABLE user drop PRIMARY KEY;</code></pre><h3 id="唯一主键"><a href="#唯一主键" class="headerlink" title="唯一主键"></a>唯一主键</h3><pre><code>-- 建表时创建唯一主键CREATE TABLE user (    id INT,    name VARCHAR(20),    UNIQUE(name));-- 添加唯一主键-- 如果建表时没有设置唯一建，还可以通过SQL语句设置（两种方式）：ALTER TABLE user ADD UNIQUE(name);ALTER TABLE user MODIFY name VARCHAR(20) UNIQUE;-- 删除唯一主键ALTER TABLE user DROP INDEX name;</code></pre><h3 id="非空约束"><a href="#非空约束" class="headerlink" title="非空约束"></a>非空约束</h3><pre><code>-- 建表时添加非空约束-- 约束某个字段不能为空CREATE TABLE user (    id INT,    name VARCHAR(20) NOT NULL);-- 移除非空约束ALTER TABLE user MODIFY name VARCHAR(20);</code></pre><h3 id="默认约束"><a href="#默认约束" class="headerlink" title="默认约束"></a>默认约束</h3><pre><code>-- 建表时添加默认约束-- 约束某个字段的默认值CREATE TABLE user2 (    id INT,    name VARCHAR(20),    age INT DEFAULT 10);-- 移除非空约束ALTER TABLE user MODIFY age INT;</code></pre><h3 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h3><pre><code>-- 班级CREATE TABLE classes (    id INT PRIMARY KEY,    name VARCHAR(20));-- 学生表CREATE TABLE students (    id INT PRIMARY KEY,    name VARCHAR(20),    -- 这里的 class_id 要和 classes 中的 id 字段相关联    class_id INT,    -- 表示 class_id 的值必须来自于 classes 中的 id 字段值    FOREIGN KEY(class_id) REFERENCES classes(id));-- 1. 主表（父表）classes 中没有的数据值，在副表（子表）students 中，是不可以使用的；-- 2. 主表中的记录被副表引用时，主表不可以被删除。</code></pre><h2 id="数据库的三大设计范式"><a href="#数据库的三大设计范式" class="headerlink" title="数据库的三大设计范式"></a>数据库的三大设计范式</h2><h3 id="1NF"><a href="#1NF" class="headerlink" title="1NF"></a>1NF</h3><p>只要字段值还可以继续拆分，就不满足第一范式。</p><p>范式设计得越详细，对某些实际操作可能会更好，但并非都有好处，需要对项目的实际情况进行设定。</p><h3 id="2NF"><a href="#2NF" class="headerlink" title="2NF"></a>2NF</h3><p>在满足第一范式的前提下，其他列都必须完全依赖于主键列。如果出现不完全依赖，只可能发生在联合主键的情况下：</p><pre><code>-- 订单表CREATE TABLE myorder (    product_id INT,    customer_id INT,    product_name VARCHAR(20),    customer_name VARCHAR(20),    PRIMARY KEY (product_id, customer_id));</code></pre><p>实际上，在这张订单表中，<code>product_name</code> 只依赖于 <code>product_id</code> ，<code>customer_name</code> 只依赖于 <code>customer_id</code> 。也就是说，<code>product_name</code> 和 <code>customer_id</code> 是没用关系的，<code>customer_name</code> 和 <code>product_id</code> 也是没有关系的。</p><p>这就不满足第二范式：其他列都必须完全依赖于主键列！</p><pre><code>CREATE TABLE myorder (    order_id INT PRIMARY KEY,    product_id INT,    customer_id INT);CREATE TABLE product (    id INT PRIMARY KEY,    name VARCHAR(20));CREATE TABLE customer (    id INT PRIMARY KEY,    name VARCHAR(20));</code></pre><p>拆分之后，<code>myorder</code> 表中的 <code>product_id</code> 和 <code>customer_id</code> 完全依赖于 <code>order_id</code> 主键，而 <code>product</code> 和 <code>customer</code> 表中的其他字段又完全依赖于主键。满足了第二范式的设计！</p><h3 id="3NF"><a href="#3NF" class="headerlink" title="3NF"></a>3NF</h3><p>在满足第二范式的前提下，除了主键列之外，其他列之间不能有传递依赖关系。</p><pre><code>CREATE TABLE myorder (    order_id INT PRIMARY KEY,    product_id INT,    customer_id INT,    customer_phone VARCHAR(15));</code></pre><p>表中的 <code>customer_phone</code> 有可能依赖于 <code>order_id</code> 、 <code>customer_id</code> 两列，也就不满足了第三范式的设计：其他列之间不能有传递依赖关系。</p><pre><code>CREATE TABLE myorder (    order_id INT PRIMARY KEY,    product_id INT,    customer_id INT);CREATE TABLE customer (    id INT PRIMARY KEY,    name VARCHAR(20),    phone VARCHAR(15));</code></pre><p>修改后就不存在其他列之间的传递依赖关系，其他列都只依赖于主键列，满足了第三范式的设计！</p><h2 id="查询练习"><a href="#查询练习" class="headerlink" title="查询练习"></a>查询练习</h2><h3 id="准备数据"><a href="#准备数据" class="headerlink" title="准备数据"></a>准备数据</h3><pre><code>-- 创建数据库CREATE DATABASE select_test;-- 切换数据库USE select_test;-- 创建学生表CREATE TABLE student (    no VARCHAR(20) PRIMARY KEY,    name VARCHAR(20) NOT NULL,    sex VARCHAR(10) NOT NULL,    birthday DATE, -- 生日    class VARCHAR(20) -- 所在班级);-- 创建教师表CREATE TABLE teacher (    no VARCHAR(20) PRIMARY KEY,    name VARCHAR(20) NOT NULL,    sex VARCHAR(10) NOT NULL,    birthday DATE,    profession VARCHAR(20) NOT NULL, -- 职称    department VARCHAR(20) NOT NULL -- 部门);-- 创建课程表CREATE TABLE course (    no VARCHAR(20) PRIMARY KEY,    name VARCHAR(20) NOT NULL,    t_no VARCHAR(20) NOT NULL, -- 教师编号    -- 表示该 tno 来自于 teacher 表中的 no 字段值    FOREIGN KEY(t_no) REFERENCES teacher(no) );-- 成绩表CREATE TABLE score (    s_no VARCHAR(20) NOT NULL, -- 学生编号    c_no VARCHAR(20) NOT NULL, -- 课程号    degree DECIMAL,    -- 成绩    -- 表示该 s_no, c_no 分别来自于 student, course 表中的 no 字段值    FOREIGN KEY(s_no) REFERENCES student(no),        FOREIGN KEY(c_no) REFERENCES course(no),    -- 设置 s_no, c_no 为联合主键    PRIMARY KEY(s_no, c_no));-- 查看所有表SHOW TABLES;-- 添加学生表数据INSERT INTO student VALUES('101', '曾华', '男', '1977-09-01', '95033');INSERT INTO student VALUES('102', '匡明', '男', '1975-10-02', '95031');INSERT INTO student VALUES('103', '王丽', '女', '1976-01-23', '95033');INSERT INTO student VALUES('104', '李军', '男', '1976-02-20', '95033');INSERT INTO student VALUES('105', '王芳', '女', '1975-02-10', '95031');INSERT INTO student VALUES('106', '陆军', '男', '1974-06-03', '95031');INSERT INTO student VALUES('107', '王尼玛', '男', '1976-02-20', '95033');INSERT INTO student VALUES('108', '张全蛋', '男', '1975-02-10', '95031');INSERT INTO student VALUES('109', '赵铁柱', '男', '1974-06-03', '95031');-- 添加教师表数据INSERT INTO teacher VALUES('804', '李诚', '男', '1958-12-02', '副教授', '计算机系');INSERT INTO teacher VALUES('856', '张旭', '男', '1969-03-12', '讲师', '电子工程系');INSERT INTO teacher VALUES('825', '王萍', '女', '1972-05-05', '助教', '计算机系');INSERT INTO teacher VALUES('831', '刘冰', '女', '1977-08-14', '助教', '电子工程系');-- 添加课程表数据INSERT INTO course VALUES('3-105', '计算机导论', '825');INSERT INTO course VALUES('3-245', '操作系统', '804');INSERT INTO course VALUES('6-166', '数字电路', '856');INSERT INTO course VALUES('9-888', '高等数学', '831');-- 添加添加成绩表数据INSERT INTO score VALUES('103', '3-105', '92');INSERT INTO score VALUES('103', '3-245', '86');INSERT INTO score VALUES('103', '6-166', '85');INSERT INTO score VALUES('105', '3-105', '88');INSERT INTO score VALUES('105', '3-245', '75');INSERT INTO score VALUES('105', '6-166', '79');INSERT INTO score VALUES('109', '3-105', '76');INSERT INTO score VALUES('109', '3-245', '68');INSERT INTO score VALUES('109', '6-166', '81');-- 查看表结构SELECT * FROM course;SELECT * FROM score;SELECT * FROM student;SELECT * FROM teacher;</code></pre><h3 id="1-到-10"><a href="#1-到-10" class="headerlink" title="1 到 10"></a>1 到 10</h3><pre><code>-- 查询 student 表的所有行SELECT * FROM student;-- 查询 student 表中的 name、sex 和 class 字段的所有行SELECT name, sex, class FROM student;-- 查询 teacher 表中不重复的 department 列-- department: 去重查询SELECT DISTINCT department FROM teacher;-- 查询 score 表中成绩在60-80之间的所有行（区间查询和运算符查询）-- BETWEEN xx AND xx: 查询区间, AND 表示 "并且"SELECT * FROM score WHERE degree BETWEEN 60 AND 80;SELECT * FROM score WHERE degree &gt; 60 AND degree &lt; 80;-- 查询 score 表中成绩为 85, 86 或 88 的行-- IN: 查询规定中的多个值SELECT * FROM score WHERE degree IN (85, 86, 88);-- 查询 student 表中 '95031' 班或性别为 '女' 的所有行-- or: 表示或者关系SELECT * FROM student WHERE class = '95031' or sex = '女';-- 以 class 降序的方式查询 student 表的所有行-- DESC: 降序，从高到低-- ASC（默认）: 升序，从低到高SELECT * FROM student ORDER BY class DESC;SELECT * FROM student ORDER BY class ASC;-- 以 c_no 升序、degree 降序查询 score 表的所有行SELECT * FROM score ORDER BY c_no ASC, degree DESC;-- 查询 "95031" 班的学生人数-- COUNT: 统计SELECT COUNT(*) FROM student WHERE class = '95031';-- 查询 score 表中的最高分的学生学号和课程编号（子查询或排序查询）。-- (SELECT MAX(degree) FROM score): 子查询，算出最高分SELECT s_no, c_no FROM score WHERE degree = (SELECT MAX(degree) FROM score);--  排序查询-- LIMIT r, n: 表示从第r行开始，查询n条数据SELECT s_no, c_no, degree FROM score ORDER BY degree DESC LIMIT 0, 1;</code></pre><h3 id="分组计算平均成绩"><a href="#分组计算平均成绩" class="headerlink" title="分组计算平均成绩"></a>分组计算平均成绩</h3><p><strong>查询每门课的平均成绩。</strong></p><pre><code>-- AVG: 平均值SELECT AVG(degree) FROM score WHERE c_no = '3-105';SELECT AVG(degree) FROM score WHERE c_no = '3-245';SELECT AVG(degree) FROM score WHERE c_no = '6-166';-- GROUP BY: 分组查询SELECT c_no, AVG(degree) FROM score GROUP BY c_no;</code></pre><h3 id="分组条件与模糊查询"><a href="#分组条件与模糊查询" class="headerlink" title="分组条件与模糊查询"></a>分组条件与模糊查询</h3><p><strong>查询 <code>score</code> 表中至少有 2 名学生选修，并以 3 开头的课程的平均分数。</strong></p><pre><code>SELECT * FROM score;-- c_no 课程编号+------+-------+--------+| s_no | c_no  | degree |+------+-------+--------+| 103  | 3-105 |     92 || 103  | 3-245 |     86 || 103  | 6-166 |     85 || 105  | 3-105 |     88 || 105  | 3-245 |     75 || 105  | 6-166 |     79 || 109  | 3-105 |     76 || 109  | 3-245 |     68 || 109  | 6-166 |     81 |+------+-------+--------+</code></pre><p>分析表发现，至少有 2 名学生选修的课程是 <code>3-105</code> 、<code>3-245</code> 、<code>6-166</code> ，以 3 开头的课程是 <code>3-105</code> 、<code>3-245</code> 。也就是说，我们要查询所有 <code>3-105</code> 和 <code>3-245</code> 的 <code>degree</code> 平均分。</p><pre><code>-- 首先把 c_no, AVG(degree) 通过分组查询出来SELECT c_no, AVG(degree) FROM score GROUP BY c_no+-------+-------------+| c_no  | AVG(degree) |+-------+-------------+| 3-105 |     85.3333 || 3-245 |     76.3333 || 6-166 |     81.6667 |+-------+-------------+-- 再查询出至少有 2 名学生选修的课程-- HAVING: 表示持有HAVING COUNT(c_no) &gt;= 2-- 并且是以 3 开头的课程-- LIKE 表示模糊查询，"%" 是一个通配符，匹配 "3" 后面的任意字符。AND c_no LIKE '3%';-- 把前面的SQL语句拼接起来，-- 后面加上一个 COUNT(*)，表示将每个分组的个数也查询出来。SELECT c_no, AVG(degree), COUNT(*) FROM score GROUP BY c_noHAVING COUNT(c_no) &gt;= 2 AND c_no LIKE '3%';+-------+-------------+----------+| c_no  | AVG(degree) | COUNT(*) |+-------+-------------+----------+| 3-105 |     85.3333 |        3 || 3-245 |     76.3333 |        3 |+-------+-------------+----------+</code></pre><h3 id="多表查询-1"><a href="#多表查询-1" class="headerlink" title="多表查询 - 1"></a>多表查询 - 1</h3><p><strong>查询所有学生的 <code>name</code>，以及该学生在 <code>score</code> 表中对应的 <code>c_no</code> 和 <code>degree</code> 。</strong></p><pre><code>SELECT no, name FROM student;+-----+-----------+| no  | name      |+-----+-----------+| 101 | 曾华      || 102 | 匡明      || 103 | 王丽      || 104 | 李军      || 105 | 王芳      || 106 | 陆军      || 107 | 王尼玛    || 108 | 张全蛋    || 109 | 赵铁柱    |+-----+-----------+SELECT s_no, c_no, degree FROM score;+------+-------+--------+| s_no | c_no  | degree |+------+-------+--------+| 103  | 3-105 |     92 || 103  | 3-245 |     86 || 103  | 6-166 |     85 || 105  | 3-105 |     88 || 105  | 3-245 |     75 || 105  | 6-166 |     79 || 109  | 3-105 |     76 || 109  | 3-245 |     68 || 109  | 6-166 |     81 |+------+-------+--------+</code></pre><p>通过分析可以发现，只要把 <code>score</code> 表中的 <code>s_no</code> 字段值替换成 <code>student</code> 表中对应的 <code>name</code> 字段值就可以了，如何做呢？</p><pre><code>-- FROM...: 表示从 student, score 表中查询-- WHERE 的条件表示为，只有在 student.no 和 score.s_no 相等时才显示出来。SELECT name, c_no, degree FROM student, score WHERE student.no = score.s_no;+-----------+-------+--------+| name      | c_no  | degree |+-----------+-------+--------+| 王丽      | 3-105 |     92 || 王丽      | 3-245 |     86 || 王丽      | 6-166 |     85 || 王芳      | 3-105 |     88 || 王芳      | 3-245 |     75 || 王芳      | 6-166 |     79 || 赵铁柱    | 3-105 |     76 || 赵铁柱    | 3-245 |     68 || 赵铁柱    | 6-166 |     81 |+-----------+-------+--------+</code></pre><h3 id="多表查询-2"><a href="#多表查询-2" class="headerlink" title="多表查询 - 2"></a>多表查询 - 2</h3><p><strong>查询所有学生的 <code>no</code> 、课程名称 ( <code>course</code> 表中的 <code>name</code> ) 和成绩 ( <code>score</code> 表中的 <code>degree</code> ) 列。</strong></p><p>只有 <code>score</code> 关联学生的 <code>no</code> ，因此只要查询 <code>score</code> 表，就能找出所有和学生相关的 <code>no</code> 和 <code>degree</code> ：</p><pre><code>SELECT s_no, c_no, degree FROM score;+------+-------+--------+| s_no | c_no  | degree |+------+-------+--------+| 103  | 3-105 |     92 || 103  | 3-245 |     86 || 103  | 6-166 |     85 || 105  | 3-105 |     88 || 105  | 3-245 |     75 || 105  | 6-166 |     79 || 109  | 3-105 |     76 || 109  | 3-245 |     68 || 109  | 6-166 |     81 |+------+-------+--------+</code></pre><p>然后查询 <code>course</code> 表：</p><pre><code>+-------+-----------------+| no    | name            |+-------+-----------------+| 3-105 | 计算机导论      || 3-245 | 操作系统        || 6-166 | 数字电路        || 9-888 | 高等数学        |+-------+-----------------+</code></pre><p>只要把 <code>score</code> 表中的 <code>c_no</code> 替换成 <code>course</code> 表中对应的 <code>name</code> 字段值就可以了。</p><pre><code>-- 增加一个查询字段 name，分别从 score、course 这两个表中查询。-- as 表示取一个该字段的别名。SELECT s_no, name as c_name, degree FROM score, courseWHERE score.c_no = course.no;+------+-----------------+--------+| s_no | c_name          | degree |+------+-----------------+--------+| 103  | 计算机导论      |     92 || 105  | 计算机导论      |     88 || 109  | 计算机导论      |     76 || 103  | 操作系统        |     86 || 105  | 操作系统        |     75 || 109  | 操作系统        |     68 || 103  | 数字电路        |     85 || 105  | 数字电路        |     79 || 109  | 数字电路        |     81 |+------+-----------------+--------+</code></pre><h3 id="三表关联查询"><a href="#三表关联查询" class="headerlink" title="三表关联查询"></a>三表关联查询</h3><p><strong>查询所有学生的 <code>name</code> 、课程名 ( <code>course</code> 表中的 <code>name</code> ) 和 <code>degree</code> 。</strong></p><p>只有 <code>score</code> 表中关联学生的学号和课堂号，我们只要围绕着 <code>score</code> 这张表查询就好了。</p><pre><code>SELECT * FROM score;+------+-------+--------+| s_no | c_no  | degree |+------+-------+--------+| 103  | 3-105 |     92 || 103  | 3-245 |     86 || 103  | 6-166 |     85 || 105  | 3-105 |     88 || 105  | 3-245 |     75 || 105  | 6-166 |     79 || 109  | 3-105 |     76 || 109  | 3-245 |     68 || 109  | 6-166 |     81 |+------+-------+--------+</code></pre><p>只要把 <code>s_no</code> 和 <code>c_no</code> 替换成 <code>student</code> 和 <code>srouse</code> 表中对应的 <code>name</code> 字段值就好了。</p><p>首先把 <code>s_no</code> 替换成 <code>student</code> 表中的 <code>name</code> 字段：</p><pre><code>SELECT name, c_no, degree FROM student, score WHERE student.no = score.s_no;+-----------+-------+--------+| name      | c_no  | degree |+-----------+-------+--------+| 王丽      | 3-105 |     92 || 王丽      | 3-245 |     86 || 王丽      | 6-166 |     85 || 王芳      | 3-105 |     88 || 王芳      | 3-245 |     75 || 王芳      | 6-166 |     79 || 赵铁柱    | 3-105 |     76 || 赵铁柱    | 3-245 |     68 || 赵铁柱    | 6-166 |     81 |+-----------+-------+--------+</code></pre><p>再把 <code>c_no</code> 替换成 <code>course</code> 表中的 <code>name</code> 字段：</p><pre><code>-- 课程表SELECT no, name FROM course;+-------+-----------------+| no    | name            |+-------+-----------------+| 3-105 | 计算机导论      || 3-245 | 操作系统        || 6-166 | 数字电路        || 9-888 | 高等数学        |+-------+-----------------+-- 由于字段名存在重复，使用 "表名.字段名 as 别名" 代替。SELECT student.name as s_name, course.name as c_name, degree FROM student, score, courseWHERE student.NO = score.s_noAND score.c_no = course.no;</code></pre><h3 id="子查询加分组求平均分"><a href="#子查询加分组求平均分" class="headerlink" title="子查询加分组求平均分"></a>子查询加分组求平均分</h3><p><strong>查询 <code>95031</code> 班学生每门课程的平均成绩。</strong></p><p>在 <code>score</code> 表中根据 <code>student</code> 表的学生编号筛选出学生的课堂号和成绩：</p><pre><code>-- IN (..): 将筛选出的学生号当做 s_no 的条件查询SELECT s_no, c_no, degree FROM scoreWHERE s_no IN (SELECT no FROM student WHERE class = '95031');+------+-------+--------+| s_no | c_no  | degree |+------+-------+--------+| 105  | 3-105 |     88 || 105  | 3-245 |     75 || 105  | 6-166 |     79 || 109  | 3-105 |     76 || 109  | 3-245 |     68 || 109  | 6-166 |     81 |+------+-------+--------+</code></pre><p>这时只要将 <code>c_no</code> 分组一下就能得出 <code>95031</code> 班学生每门课的平均成绩：</p><pre><code>SELECT c_no, AVG(degree) FROM scoreWHERE s_no IN (SELECT no FROM student WHERE class = '95031')GROUP BY c_no;+-------+-------------+| c_no  | AVG(degree) |+-------+-------------+| 3-105 |     82.0000 || 3-245 |     71.5000 || 6-166 |     80.0000 |+-------+-------------+</code></pre><h3 id="子查询-1"><a href="#子查询-1" class="headerlink" title="子查询 - 1"></a>子查询 - 1</h3><p><strong>查询在 <code>3-105</code> 课程中，所有成绩高于 <code>109</code> 号同学的记录。</strong></p><p>首先筛选出课堂号为 <code>3-105</code> ，在找出所有成绩高于 <code>109</code> 号同学的的行。</p><pre><code>SELECT * FROM score WHERE c_no = '3-105'AND degree &gt; (SELECT degree FROM score WHERE s_no = '109' AND c_no = '3-105');</code></pre><h3 id="子查询-2"><a href="#子查询-2" class="headerlink" title="子查询 - 2"></a>子查询 - 2</h3><p><strong>查询所有成绩高于 <code>109</code> 号同学的 <code>3-105</code> 课程成绩记录。</strong></p><pre><code>-- 不限制课程号，只要成绩大于109号同学的3-105课程成绩就可以。SELECT * FROM scoreWHERE degree &gt; (SELECT degree FROM score WHERE s_no = '109' AND c_no = '3-105');</code></pre><h3 id="YEAR-函数与带-IN-关键字查询"><a href="#YEAR-函数与带-IN-关键字查询" class="headerlink" title="YEAR 函数与带 IN 关键字查询"></a>YEAR 函数与带 IN 关键字查询</h3><p><strong>查询所有和 <code>101</code> 、<code>108</code> 号学生同年出生的 <code>no</code> 、<code>name</code> 、<code>birthday</code> 列。</strong></p><pre><code>-- YEAR(..): 取出日期中的年份SELECT no, name, birthday FROM studentWHERE YEAR(birthday) IN (SELECT YEAR(birthday) FROM student WHERE no IN (101, 108));</code></pre><h3 id="多层嵌套子查询"><a href="#多层嵌套子查询" class="headerlink" title="多层嵌套子查询"></a>多层嵌套子查询</h3><p><strong>查询 <code>'张旭'</code> 教师任课的学生成绩表。</strong></p><p>首先找到教师编号：</p><pre><code>SELECT NO FROM teacher WHERE NAME = '张旭'</code></pre><p>通过 <code>sourse</code> 表找到该教师课程号：</p><pre><code>SELECT NO FROM course WHERE t_no = ( SELECT NO FROM teacher WHERE NAME = '张旭' );</code></pre><p>通过筛选出的课程号查询成绩表：</p><pre><code>SELECT * FROM score WHERE c_no = (    SELECT no FROM course WHERE t_no = (         SELECT no FROM teacher WHERE NAME = '张旭'     ));</code></pre><h3 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h3><p><strong>查询某选修课程多于5个同学的教师姓名。</strong></p><p>首先在 <code>teacher</code> 表中，根据 <code>no</code> 字段来判断该教师的同一门课程是否有至少5名学员选修：</p><pre><code>-- 查询 teacher 表SELECT no, name FROM teacher;+-----+--------+| no  | name   |+-----+--------+| 804 | 李诚   || 825 | 王萍   || 831 | 刘冰   || 856 | 张旭   |+-----+--------+SELECT name FROM teacher WHERE no IN (    -- 在这里找到对应的条件);</code></pre><p>查看和教师编号有有关的表的信息：</p><pre><code>SELECT * FROM course;-- t_no: 教师编号+-------+-----------------+------+| no    | name            | t_no |+-------+-----------------+------+| 3-105 | 计算机导论      | 825  || 3-245 | 操作系统        | 804  || 6-166 | 数字电路        | 856  || 9-888 | 高等数学        | 831  |+-------+-----------------+------+</code></pre><p>我们已经找到和教师编号有关的字段就在 <code>course</code> 表中，但是还无法知道哪门课程至少有5名学生选修，所以还需要根据 <code>score</code> 表来查询：</p><pre><code>-- 在此之前向 score 插入一些数据，以便丰富查询条件。INSERT INTO score VALUES ('101', '3-105', '90');INSERT INTO score VALUES ('102', '3-105', '91');INSERT INTO score VALUES ('104', '3-105', '89');-- 查询 score 表SELECT * FROM score;+------+-------+--------+| s_no | c_no  | degree |+------+-------+--------+| 101  | 3-105 |     90 || 102  | 3-105 |     91 || 103  | 3-105 |     92 || 103  | 3-245 |     86 || 103  | 6-166 |     85 || 104  | 3-105 |     89 || 105  | 3-105 |     88 || 105  | 3-245 |     75 || 105  | 6-166 |     79 || 109  | 3-105 |     76 || 109  | 3-245 |     68 || 109  | 6-166 |     81 |+------+-------+--------+-- 在 score 表中将 c_no 作为分组，并且限制 c_no 持有至少 5 条数据。SELECT c_no FROM score GROUP BY c_no HAVING COUNT(*) &gt; 5;+-------+| c_no  |+-------+| 3-105 |+-------+</code></pre><p>根据筛选出来的课程号，找出在某课程中，拥有至少5名学员的教师编号：</p><pre><code>SELECT t_no FROM course WHERE no IN (    SELECT c_no FROM score GROUP BY c_no HAVING COUNT(*) &gt; 5);+------+| t_no |+------+| 825  |+------+</code></pre><p>在 <code>teacher</code> 表中，根据筛选出来的教师编号找到教师姓名：</p><pre><code>SELECT name FROM teacher WHERE no IN (    -- 最终条件    SELECT t_no FROM course WHERE no IN (        SELECT c_no FROM score GROUP BY c_no HAVING COUNT(*) &gt; 5    ));</code></pre><h3 id="子查询-3"><a href="#子查询-3" class="headerlink" title="子查询 - 3"></a>子查询 - 3</h3><p><strong>查询 “计算机系” 课程的成绩表。</strong></p><p>思路是，先找出 <code>course</code> 表中所有 <code>计算机系</code> 课程的编号，然后根据这个编号查询 <code>score</code> 表。</p><pre><code>-- 通过 teacher 表查询所有 `计算机系` 的教师编号SELECT no, name, department FROM teacher WHERE department = '计算机系'+-----+--------+--------------+| no  | name   | department   |+-----+--------+--------------+| 804 | 李诚   | 计算机系     || 825 | 王萍   | 计算机系     |+-----+--------+--------------+-- 通过 course 表查询该教师的课程编号SELECT no FROM course WHERE t_no IN (    SELECT no FROM teacher WHERE department = '计算机系');+-------+| no    |+-------+| 3-245 || 3-105 |+-------+-- 根据筛选出来的课程号查询成绩表SELECT * FROM score WHERE c_no IN (    SELECT no FROM course WHERE t_no IN (        SELECT no FROM teacher WHERE department = '计算机系'    ));+------+-------+--------+| s_no | c_no  | degree |+------+-------+--------+| 103  | 3-245 |     86 || 105  | 3-245 |     75 || 109  | 3-245 |     68 || 101  | 3-105 |     90 || 102  | 3-105 |     91 || 103  | 3-105 |     92 || 104  | 3-105 |     89 || 105  | 3-105 |     88 || 109  | 3-105 |     76 |+------+-------+--------+</code></pre><h3 id="UNION-和-NOTIN-的使用"><a href="#UNION-和-NOTIN-的使用" class="headerlink" title="UNION 和 NOTIN 的使用"></a>UNION 和 NOTIN 的使用</h3><p><strong>查询 <code>计算机系</code> 与 <code>电子工程系</code> 中的不同职称的教师。</strong></p><pre><code>-- NOT: 代表逻辑非SELECT * FROM teacher WHERE department = '计算机系' AND profession NOT IN (    SELECT profession FROM teacher WHERE department = '电子工程系')-- 合并两个集UNIONSELECT * FROM teacher WHERE department = '电子工程系' AND profession NOT IN (    SELECT profession FROM teacher WHERE department = '计算机系');</code></pre><h3 id="ANY-表示至少一个-DESC-降序"><a href="#ANY-表示至少一个-DESC-降序" class="headerlink" title="ANY 表示至少一个 - DESC ( 降序 )"></a>ANY 表示至少一个 - DESC ( 降序 )</h3><p><strong>查询课程 <code>3-105</code> 且成绩 至少 高于 <code>3-245</code> 的 <code>score</code> 表。</strong></p><pre><code>SELECT * FROM score WHERE c_no = '3-105';+------+-------+--------+| s_no | c_no  | degree |+------+-------+--------+| 101  | 3-105 |     90 || 102  | 3-105 |     91 || 103  | 3-105 |     92 || 104  | 3-105 |     89 || 105  | 3-105 |     88 || 109  | 3-105 |     76 |+------+-------+--------+SELECT * FROM score WHERE c_no = '3-245';+------+-------+--------+| s_no | c_no  | degree |+------+-------+--------+| 103  | 3-245 |     86 || 105  | 3-245 |     75 || 109  | 3-245 |     68 |+------+-------+--------+-- ANY: 符合SQL语句中的任意条件。-- 也就是说，在 3-105 成绩中，只要有一个大于从 3-245 筛选出来的任意行就符合条件，-- 最后根据降序查询结果。SELECT * FROM score WHERE c_no = '3-105' AND degree &gt; ANY(    SELECT degree FROM score WHERE c_no = '3-245') ORDER BY degree DESC;+------+-------+--------+| s_no | c_no  | degree |+------+-------+--------+| 103  | 3-105 |     92 || 102  | 3-105 |     91 || 101  | 3-105 |     90 || 104  | 3-105 |     89 || 105  | 3-105 |     88 || 109  | 3-105 |     76 |+------+-------+--------+</code></pre><h3 id="表示所有的-ALL"><a href="#表示所有的-ALL" class="headerlink" title="表示所有的 ALL"></a>表示所有的 ALL</h3><p><strong>查询课程 <code>3-105</code> 且成绩高于 <code>3-245</code> 的 <code>score</code> 表。</strong></p><pre><code>-- 只需对上一道题稍作修改。-- ALL: 符合SQL语句中的所有条件。-- 也就是说，在 3-105 每一行成绩中，都要大于从 3-245 筛选出来全部行才算符合条件。SELECT * FROM score WHERE c_no = '3-105' AND degree &gt; ALL(    SELECT degree FROM score WHERE c_no = '3-245');+------+-------+--------+| s_no | c_no  | degree |+------+-------+--------+| 101  | 3-105 |     90 || 102  | 3-105 |     91 || 103  | 3-105 |     92 || 104  | 3-105 |     89 || 105  | 3-105 |     88 |+------+-------+--------+</code></pre><h3 id="复制表的数据作为条件查询"><a href="#复制表的数据作为条件查询" class="headerlink" title="复制表的数据作为条件查询"></a>复制表的数据作为条件查询</h3><p><strong>查询某课程成绩比该课程平均成绩低的 <code>score</code> 表。</strong></p><pre><code>-- 查询平均分SELECT c_no, AVG(degree) FROM score GROUP BY c_no;+-------+-------------+| c_no  | AVG(degree) |+-------+-------------+| 3-105 |     87.6667 || 3-245 |     76.3333 || 6-166 |     81.6667 |+-------+-------------+-- 查询 score 表SELECT degree FROM score;+--------+| degree |+--------+|     90 ||     91 ||     92 ||     86 ||     85 ||     89 ||     88 ||     75 ||     79 ||     76 ||     68 ||     81 |+--------+-- 将表 b 作用于表 a 中查询数据-- score a (b): 将表声明为 a (b)，-- 如此就能用 a.c_no = b.c_no 作为条件执行查询了。SELECT * FROM score a WHERE degree &lt; (    (SELECT AVG(degree) FROM score b WHERE a.c_no = b.c_no));+------+-------+--------+| s_no | c_no  | degree |+------+-------+--------+| 105  | 3-245 |     75 || 105  | 6-166 |     79 || 109  | 3-105 |     76 || 109  | 3-245 |     68 || 109  | 6-166 |     81 |+------+-------+--------+</code></pre><h3 id="子查询-4"><a href="#子查询-4" class="headerlink" title="子查询 - 4"></a>子查询 - 4</h3><p><strong>查询所有任课 ( 在 <code>course</code> 表里有课程 ) 教师的 <code>name</code> 和 <code>department</code></strong> 。</p><pre><code>SELECT name, department FROM teacher WHERE no IN (SELECT t_no FROM course);+--------+-----------------+| name   | department      |+--------+-----------------+| 李诚   | 计算机系        || 王萍   | 计算机系        || 刘冰   | 电子工程系      || 张旭   | 电子工程系      |+--------+-----------------+</code></pre><h3 id="条件加组筛选"><a href="#条件加组筛选" class="headerlink" title="条件加组筛选"></a>条件加组筛选</h3><p><strong>查询 <code>student</code> 表中至少有 2 名男生的 <code>class</code> 。</strong></p><pre><code>-- 查看学生表信息SELECT * FROM student;+-----+-----------+-----+------------+-------+| no  | name      | sex | birthday   | class |+-----+-----------+-----+------------+-------+| 101 | 曾华      | 男  | 1977-09-01 | 95033 || 102 | 匡明      | 男  | 1975-10-02 | 95031 || 103 | 王丽      | 女  | 1976-01-23 | 95033 || 104 | 李军      | 男  | 1976-02-20 | 95033 || 105 | 王芳      | 女  | 1975-02-10 | 95031 || 106 | 陆军      | 男  | 1974-06-03 | 95031 || 107 | 王尼玛    | 男  | 1976-02-20 | 95033 || 108 | 张全蛋    | 男  | 1975-02-10 | 95031 || 109 | 赵铁柱    | 男  | 1974-06-03 | 95031 || 110 | 张飞      | 男  | 1974-06-03 | 95038 |+-----+-----------+-----+------------+-------+-- 只查询性别为男，然后按 class 分组，并限制 class 行大于 1。SELECT class FROM student WHERE sex = '男' GROUP BY class HAVING COUNT(*) &gt; 1;+-------+| class |+-------+| 95033 || 95031 |+-------+</code></pre><h3 id="NOTLIKE-模糊查询取反"><a href="#NOTLIKE-模糊查询取反" class="headerlink" title="NOTLIKE 模糊查询取反"></a>NOTLIKE 模糊查询取反</h3><p><strong>查询 <code>student</code> 表中不姓 “王” 的同学记录。</strong></p><pre><code>-- NOT: 取反-- LIKE: 模糊查询mysql&gt; SELECT * FROM student WHERE name NOT LIKE '王%';+-----+-----------+-----+------------+-------+| no  | name      | sex | birthday   | class |+-----+-----------+-----+------------+-------+| 101 | 曾华      | 男  | 1977-09-01 | 95033 || 102 | 匡明      | 男  | 1975-10-02 | 95031 || 104 | 李军      | 男  | 1976-02-20 | 95033 || 106 | 陆军      | 男  | 1974-06-03 | 95031 || 108 | 张全蛋    | 男  | 1975-02-10 | 95031 || 109 | 赵铁柱    | 男  | 1974-06-03 | 95031 || 110 | 张飞      | 男  | 1974-06-03 | 95038 |+-----+-----------+-----+------------+-------+</code></pre><h3 id="YEAR-与-NOW-函数"><a href="#YEAR-与-NOW-函数" class="headerlink" title="YEAR 与 NOW 函数"></a>YEAR 与 NOW 函数</h3><p><strong>查询 <code>student</code> 表中每个学生的姓名和年龄。</strong></p><pre><code>-- 使用函数 YEAR(NOW()) 计算出当前年份，减去出生年份后得出年龄。SELECT name, YEAR(NOW()) - YEAR(birthday) as age FROM student;+-----------+------+| name      | age  |+-----------+------+| 曾华      |   42 || 匡明      |   44 || 王丽      |   43 || 李军      |   43 || 王芳      |   44 || 陆军      |   45 || 王尼玛    |   43 || 张全蛋    |   44 || 赵铁柱    |   45 || 张飞      |   45 |+-----------+------+</code></pre><h3 id="MAX-与-MIN-函数"><a href="#MAX-与-MIN-函数" class="headerlink" title="MAX 与 MIN 函数"></a>MAX 与 MIN 函数</h3><p><strong>查询 <code>student</code> 表中最大和最小的 <code>birthday</code> 值。</strong></p><pre><code>SELECT MAX(birthday), MIN(birthday) FROM student;+---------------+---------------+| MAX(birthday) | MIN(birthday) |+---------------+---------------+| 1977-09-01    | 1974-06-03    |+---------------+---------------+</code></pre><h3 id="多段排序"><a href="#多段排序" class="headerlink" title="多段排序"></a>多段排序</h3><p><strong>以 <code>class</code> 和 <code>birthday</code> 从大到小的顺序查询 <code>student</code> 表。</strong></p><pre><code>SELECT * FROM student ORDER BY class DESC, birthday;+-----+-----------+-----+------------+-------+| no  | name      | sex | birthday   | class |+-----+-----------+-----+------------+-------+| 110 | 张飞      | 男  | 1974-06-03 | 95038 || 103 | 王丽      | 女  | 1976-01-23 | 95033 || 104 | 李军      | 男  | 1976-02-20 | 95033 || 107 | 王尼玛    | 男  | 1976-02-20 | 95033 || 101 | 曾华      | 男  | 1977-09-01 | 95033 || 106 | 陆军      | 男  | 1974-06-03 | 95031 || 109 | 赵铁柱    | 男  | 1974-06-03 | 95031 || 105 | 王芳      | 女  | 1975-02-10 | 95031 || 108 | 张全蛋    | 男  | 1975-02-10 | 95031 || 102 | 匡明      | 男  | 1975-10-02 | 95031 |+-----+-----------+-----+------------+-------+</code></pre><h3 id="子查询-5"><a href="#子查询-5" class="headerlink" title="子查询 - 5"></a>子查询 - 5</h3><p><strong>查询 “男” 教师及其所上的课程。</strong></p><pre><code>SELECT * FROM course WHERE t_no in (SELECT no FROM teacher WHERE sex = '男');+-------+--------------+------+| no    | name         | t_no |+-------+--------------+------+| 3-245 | 操作系统     | 804  || 6-166 | 数字电路     | 856  |+-------+--------------+------+</code></pre><h3 id="MAX-函数与子查询"><a href="#MAX-函数与子查询" class="headerlink" title="MAX 函数与子查询"></a>MAX 函数与子查询</h3><p><strong>查询最高分同学的 <code>score</code> 表。</strong></p><pre><code>-- 找出最高成绩（该查询只能有一个结果）SELECT MAX(degree) FROM score;-- 根据上面的条件筛选出所有最高成绩表，-- 该查询可能有多个结果，假设 degree 值多次符合条件。SELECT * FROM score WHERE degree = (SELECT MAX(degree) FROM score);+------+-------+--------+| s_no | c_no  | degree |+------+-------+--------+| 103  | 3-105 |     92 |+------+-------+--------+</code></pre><h3 id="子查询-6"><a href="#子查询-6" class="headerlink" title="子查询 - 6"></a>子查询 - 6</h3><p><strong>查询和 “李军” 同性别的所有同学 <code>name</code> 。</strong></p><pre><code>-- 首先将李军的性别作为条件取出来SELECT sex FROM student WHERE name = '李军';+-----+| sex |+-----+| 男  |+-----+-- 根据性别查询 name 和 sexSELECT name, sex FROM student WHERE sex = (    SELECT sex FROM student WHERE name = '李军');+-----------+-----+| name      | sex |+-----------+-----+| 曾华      | 男  || 匡明      | 男  || 李军      | 男  || 陆军      | 男  || 王尼玛    | 男  || 张全蛋    | 男  || 赵铁柱    | 男  || 张飞      | 男  |+-----------+-----+</code></pre><h3 id="子查询-7"><a href="#子查询-7" class="headerlink" title="子查询 - 7"></a>子查询 - 7</h3><p><strong>查询和 “李军” 同性别且同班的同学 <code>name</code> 。</strong></p><pre><code>SELECT name, sex, class FROM student WHERE sex = (    SELECT sex FROM student WHERE name = '李军') AND class = (    SELECT class FROM student WHERE name = '李军');+-----------+-----+-------+| name      | sex | class |+-----------+-----+-------+| 曾华      | 男  | 95033 || 李军      | 男  | 95033 || 王尼玛    | 男  | 95033 |+-----------+-----+-------+</code></pre><h3 id="子查询-8"><a href="#子查询-8" class="headerlink" title="子查询 - 8"></a>子查询 - 8</h3><p><strong>查询所有选修 “计算机导论” 课程的 “男” 同学成绩表。</strong></p><p>需要的 “计算机导论” 和性别为 “男” 的编号可以在 <code>course</code> 和 <code>student</code> 表中找到。</p><pre><code>SELECT * FROM score WHERE c_no = (    SELECT no FROM course WHERE name = '计算机导论') AND s_no IN (    SELECT no FROM student WHERE sex = '男');+------+-------+--------+| s_no | c_no  | degree |+------+-------+--------+| 101  | 3-105 |     90 || 102  | 3-105 |     91 || 104  | 3-105 |     89 || 109  | 3-105 |     76 |+------+-------+--------+</code></pre><h3 id="按等级查询"><a href="#按等级查询" class="headerlink" title="按等级查询"></a>按等级查询</h3><p>建立一个 <code>grade</code> 表代表学生的成绩等级，并插入数据：</p><pre><code>CREATE TABLE grade (    low INT(3),    upp INT(3),    grade char(1));INSERT INTO grade VALUES (90, 100, 'A');INSERT INTO grade VALUES (80, 89, 'B');INSERT INTO grade VALUES (70, 79, 'C');INSERT INTO grade VALUES (60, 69, 'D');INSERT INTO grade VALUES (0, 59, 'E');SELECT * FROM grade;+------+------+-------+| low  | upp  | grade |+------+------+-------+|   90 |  100 | A     ||   80 |   89 | B     ||   70 |   79 | C     ||   60 |   69 | D     ||    0 |   59 | E     |+------+------+-------+</code></pre><p><strong>查询所有学生的 <code>s_no</code> 、<code>c_no</code> 和 <code>grade</code> 列。</strong></p><p>思路是，使用区间 ( <code>BETWEEN</code> ) 查询，判断学生的成绩 ( <code>degree</code> ) 在 <code>grade</code> 表的 <code>low</code> 和 <code>upp</code> 之间。</p><pre><code>SELECT s_no, c_no, grade FROM score, grade WHERE degree BETWEEN low AND upp;+------+-------+-------+| s_no | c_no  | grade |+------+-------+-------+| 101  | 3-105 | A     || 102  | 3-105 | A     || 103  | 3-105 | A     || 103  | 3-245 | B     || 103  | 6-166 | B     || 104  | 3-105 | B     || 105  | 3-105 | B     || 105  | 3-245 | C     || 105  | 6-166 | C     || 109  | 3-105 | C     || 109  | 3-245 | D     || 109  | 6-166 | B     |+------+-------+-------+</code></pre><h3 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h3><p>准备用于测试连接查询的数据：</p><pre><code>CREATE DATABASE testJoin;CREATE TABLE person (    id INT,    name VARCHAR(20),    cardId INT);CREATE TABLE card (    id INT,    name VARCHAR(20));INSERT INTO card VALUES (1, '饭卡'), (2, '建行卡'), (3, '农行卡'), (4, '工商卡'), (5, '邮政卡');SELECT * FROM card;+------+-----------+| id   | name      |+------+-----------+|    1 | 饭卡      ||    2 | 建行卡    ||    3 | 农行卡    ||    4 | 工商卡    ||    5 | 邮政卡    |+------+-----------+INSERT INTO person VALUES (1, '张三', 1), (2, '李四', 3), (3, '王五', 6);SELECT * FROM person;+------+--------+--------+| id   | name   | cardId |+------+--------+--------+|    1 | 张三   |      1 ||    2 | 李四   |      3 ||    3 | 王五   |      6 |+------+--------+--------+</code></pre><p>分析两张表发现，<code>person</code> 表并没有为 <code>cardId</code> 字段设置一个在 <code>card</code> 表中对应的 <code>id</code> 外键。如果设置了的话，<code>person</code> 中 <code>cardId</code> 字段值为 <code>6</code> 的行就插不进去，因为该 <code>cardId</code> 值在 <code>card</code> 表中并没有。</p><h4 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h4><p>要查询这两张表中有关系的数据，可以使用 <code>INNER JOIN</code> ( 内连接 ) 将它们连接在一起。</p><pre><code>-- INNER JOIN: 表示为内连接，将两张表拼接在一起。-- on: 表示要执行某个条件。SELECT * FROM person INNER JOIN card on person.cardId = card.id;+------+--------+--------+------+-----------+| id   | name   | cardId | id   | name      |+------+--------+--------+------+-----------+|    1 | 张三   |      1 |    1 | 饭卡      ||    2 | 李四   |      3 |    3 | 农行卡    |+------+--------+--------+------+-----------+-- 将 INNER 关键字省略掉，结果也是一样的。-- SELECT * FROM person JOIN card on person.cardId = card.id;</code></pre><blockquote><p>注意：<code>card</code> 的整张表被连接到了右边。</p></blockquote><h4 id="左外连接"><a href="#左外连接" class="headerlink" title="左外连接"></a>左外连接</h4><p>完整显示左边的表 ( <code>person</code> ) ，右边的表如果符合条件就显示，不符合则补 <code>NULL</code> 。</p><pre><code>-- LEFT JOIN 也叫做 LEFT OUTER JOIN，用这两种方式的查询结果是一样的。SELECT * FROM person LEFT JOIN card on person.cardId = card.id;+------+--------+--------+------+-----------+| id   | name   | cardId | id   | name      |+------+--------+--------+------+-----------+|    1 | 张三   |      1 |    1 | 饭卡      ||    2 | 李四   |      3 |    3 | 农行卡    ||    3 | 王五   |      6 | NULL | NULL      |+------+--------+--------+------+-----------+</code></pre><h4 id="右外链接"><a href="#右外链接" class="headerlink" title="右外链接"></a>右外链接</h4><p>完整显示右边的表 ( <code>card</code> ) ，左边的表如果符合条件就显示，不符合则补 <code>NULL</code> 。</p><pre><code>SELECT * FROM person RIGHT JOIN card on person.cardId = card.id;+------+--------+--------+------+-----------+| id   | name   | cardId | id   | name      |+------+--------+--------+------+-----------+|    1 | 张三   |      1 |    1 | 饭卡      ||    2 | 李四   |      3 |    3 | 农行卡    || NULL | NULL   |   NULL |    2 | 建行卡    || NULL | NULL   |   NULL |    4 | 工商卡    || NULL | NULL   |   NULL |    5 | 邮政卡    |+------+--------+--------+------+-----------+</code></pre><h4 id="全外链接"><a href="#全外链接" class="headerlink" title="全外链接"></a>全外链接</h4><p>完整显示两张表的全部数据。</p><pre><code>-- MySQL 不支持这种语法的全外连接-- SELECT * FROM person FULL JOIN card on person.cardId = card.id;-- 出现错误：-- ERROR 1054 (42S22): Unknown column 'person.cardId' in 'on clause'-- MySQL全连接语法，使用 UNION 将两张表合并在一起。SELECT * FROM person LEFT JOIN card on person.cardId = card.idUNIONSELECT * FROM person RIGHT JOIN card on person.cardId = card.id;+------+--------+--------+------+-----------+| id   | name   | cardId | id   | name      |+------+--------+--------+------+-----------+|    1 | 张三   |      1 |    1 | 饭卡      ||    2 | 李四   |      3 |    3 | 农行卡    ||    3 | 王五   |      6 | NULL | NULL      || NULL | NULL   |   NULL |    2 | 建行卡    || NULL | NULL   |   NULL |    4 | 工商卡    || NULL | NULL   |   NULL |    5 | 邮政卡    |+------+--------+--------+------+-----------+</code></pre><blockquote><p>参考</p><p>特别感谢！</p><p><a href="https://github.com/hjzCy/sql_node" target="_blank" rel="noopener">https://github.com/hjzCy/sql_node</a></p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> sql </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图床</title>
      <link href="/blog/2020/02/01/tu-chuang/"/>
      <url>/blog/2020/02/01/tu-chuang/</url>
      
        <content type="html"><![CDATA[<p>编写md文档时，图片处理及其让人头疼，一旦本地图片丢失，md文档中图片就会无法显示，所以我们需要将图保存到图床，即使本地图片丢失，md也不受影响。</p><p>免费图床方案：PicGo+jsdelivr+github</p><h2 id="本文用到的工具或网站"><a href="#本文用到的工具或网站" class="headerlink" title="本文用到的工具或网站"></a>本文用到的工具或网站</h2><p>PicGo</p><p>jsdelivr</p><p>github</p><h2 id="下载PicGo"><a href="#下载PicGo" class="headerlink" title="下载PicGo"></a>下载PicGo</h2><p>首先进入PicGo的<a href="https://github.com/Molunerfinn/PicGo/releases" target="_blank" rel="noopener">下载地址</a> 选择最新版本下载，根据自己的系统下载对应的安装包，我这里是Windows</p><p><img src="https://cdn.jsdelivr.net/gh/Tian-JQ/images/img/eBQS0g.png" alt=""></p><h2 id="配置PicGo"><a href="#配置PicGo" class="headerlink" title="配置PicGo"></a>配置PicGo</h2><h3 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h3><p>首先创建一个github仓库，名字可以随便取，然后勾选README初始化仓库</p><p><img src="https://cdn.jsdelivr.net/gh/Tian-JQ/images/img/PAmFEMvwclOSate.png" alt=""></p><h3 id="生成token"><a href="#生成token" class="headerlink" title="生成token"></a>生成token</h3><p>【进入github】-【点击头像】-【settings】-【developer settings】-【Personal access tokens】</p><p><img src="https://cdn.jsdelivr.net/gh/Tian-JQ/images/img/eDJIld.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/Tian-JQ/images/img/eDJo6A.png" alt=""></p><p>点击【Generate new token】</p><p><img src="https://cdn.jsdelivr.net/gh/Tian-JQ/images/img/eDYS6s.png" alt=""></p><p>自定义一个名字，然后勾选【repo】最后点绿色按钮创建即可</p><p><img src="https://cdn.jsdelivr.net/gh/Tian-JQ/images/img/eDYAtU.png" alt=""></p><p>请复制你的token，它只显示一次，请妥善保管</p><p><img src="https://cdn.jsdelivr.net/gh/Tian-JQ/images/img/eDYM0x.png" alt=""></p><h3 id="配置github图床"><a href="#配置github图床" class="headerlink" title="配置github图床"></a>配置github图床</h3><p>先打开你安装好的picgo然后左栏依次选择【图床设置】-【github图床】</p><p>如果你打开picgo时没有直接出来界面，它可能藏在你的托盘图标处<br>仓库名格式是你的用户名/仓库名（注意此处不要有空格！！）<br>分支是master<br>token填我们刚刚生成的<br>存储路径可以填也可以不填，如果你填了img/，它就会上传到你仓库的img目录下<br>自定义域名的格式：<a href="https://cdn.jsdelivr.net/gh/用户名/仓库名（注意此处不要有空格）" target="_blank" rel="noopener">https://cdn.jsdelivr.net/gh/用户名/仓库名（注意此处不要有空格）</a><br>最后记得确定保存</p><h3 id="上传图片"><a href="#上传图片" class="headerlink" title="上传图片"></a>上传图片</h3><p>点击上传区记得图床选【github图床】，直接将图片拖入即可上传。</p><p>可以看到在你的github仓库有了第一张图片</p><h3 id="配合jsdelivr使用"><a href="#配合jsdelivr使用" class="headerlink" title="配合jsdelivr使用"></a>配合jsdelivr使用</h3><p>链接格式：<a href="https://cdn.jsdelivr.net/gh/你的用户名/仓库名/文件路径" target="_blank" rel="noopener">https://cdn.jsdelivr.net/gh/你的用户名/仓库名/文件路径</a></p><p>我们在上传的时候会自动复制这个格式的链接，大家可以可以直接复制查看</p><p>然后你就可以通过这个链接访问你的图片了</p><h3 id="Bug"><a href="#Bug" class="headerlink" title="Bug"></a>Bug</h3><p>上传图片时出现<code>服务端错误及上传出错</code>，检查配置是否正确，尤其注意自己的用户名/仓库名（注意此处不要有空格！！）。</p><p><u>————————————————————————————–</u></p><blockquote><p>参考文档</p><p>特别鸣谢！</p><p><a href="https://301technology.cn/2020/01/17/image/" target="_blank" rel="noopener">https://301technology.cn/2020/01/17/image/</a></p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> github </category>
          
      </categories>
      
      
        <tags>
            
            <tag> github </tag>
            
            <tag> markdown </tag>
            
            <tag> 图床 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo+GitHub搭建个人博客</title>
      <link href="/blog/2020/01/31/hexo-github-da-jian-ge-ren-bo-ke/"/>
      <url>/blog/2020/01/31/hexo-github-da-jian-ge-ren-bo-ke/</url>
      
        <content type="html"><![CDATA[<h2 id="一-搭建"><a href="#一-搭建" class="headerlink" title="一  搭建"></a>一  搭建</h2><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ul><li>1.安装<code>Git</code></li><li>2.安装<code>Node.js</code></li><li>3.安装<code>Hexo</code></li><li>4.<code>GitHub</code>创建个人仓库</li><li>5.生成<code>SSH</code>添加到<code>GitHub</code></li><li>6.将<code>hexo</code>部署到<code>GitHub</code></li><li>7.设置个人域名</li><li>8.发布文章化</li></ul><h3 id="1-安装Git"><a href="#1-安装Git" class="headerlink" title="1.安装Git"></a>1.安装<code>Git</code></h3><p>为了把本地的网页文件上传到<code>github</code>上面去，需要用到工具—Git<a href="https://git-scm.com/download" target="_blank" rel="noopener">[下载地址]</a>。</p><p><strong>windows：</strong>到<code>git</code>官网上下载<code>.exe</code>文件,<a href="https://git-scm.com/download/win" target="_blank" rel="noopener">Download git</a>,安装选项还是全部默认，只不过最后一步添加路径时选择<code>Use Git from the Windows Command Prompt</code>，这样我们就可以直接在命令提示符里打开<code>git</code>了。</p><blockquote><p><code>windows</code>在<code>git</code>安装完后，就可以直接使用<code>git bash</code>来敲命令行了，不用自带的<code>cmd</code>。</p></blockquote><p><strong>linux：</strong>对<code>linux</code>来说实在是太简单了，因为最早的<code>git</code>就是在<code>linux</code>上编写的，只需要一行代码</p><pre><code>sudo apt-get install git</code></pre><p>安装完成后在命令提示符中输入<code>git --version</code>来查看一下版本验证是否安装成功。</p><h3 id="2-安装Node-js"><a href="#2-安装Node-js" class="headerlink" title="2.安装Node.js"></a>2.安装<code>Node.js</code></h3><p><code>Hexo</code>是基于<code>node.js</code>编写的，所以需要安装一下<code>node.js</code>和里面的<code>npm</code>工具。</p><p><strong>windows：</strong>下载稳定版或者最新版都可以<a href="http://nodejs.cn/download/" target="_blank" rel="noopener">Node.js</a>，安装选项全部默认，一路点击<code>Next</code>。<br>最后安装好之后，按<code>Win+R</code>打开命令提示符，输入<code>node -v</code>和<code>npm -v</code>，如果出现版本号，那么就安装成功了。</p><p><strong>linux：</strong>命令行安装：</p><pre><code>sudo apt-get install nodejssudo apt-get install npm</code></pre><h3 id="3-安装Hexo"><a href="#3-安装Hexo" class="headerlink" title="3.安装Hexo"></a>3.安装<code>Hexo</code></h3><p>前面<code>git</code>和<code>nodejs</code>安装好后，就可以安装<code>hexo</code>了，输入<code>npm install -g hexo-cli</code>安装<code>Hexo</code>。可能会有几个报错，无视它就行。</p><pre><code>npm install -g hexo-cli</code></pre><p>安装完后输入<code>hexo -v</code>验证是否安装成功。</p><p>然后<code>cd</code>到这个文件夹下（或者在这个文件夹下直接右键<code>git bash</code>打开）。</p><p>比如我的博客文件都存放在<code>D:\Document\Blog</code>目录下。</p><p>在该目录下右键点击<code>Git Bash Here</code>，打开<code>git</code>的控制台窗口，以后我们所有的操作都在<code>git</code>控制台进行，就不用<code>Windows</code>自带的<code>cmd</code>了。</p><p>接下来初始化一下<code>hexo</code>，即初始化我们的网站，输入<code>hexo init</code>初始化文件夹</p><pre><code>hexo init</code></pre><p>这个<code>Blog</code>可以自己取什么名字都行，然后，接着输入<code>npm install</code>安装必备的组件。</p><pre><code>cd Blog      //进入这个MyBlog文件夹npm install</code></pre><p>新建完成后，指定文件夹<code>Blog</code>目录下有：</p><ul><li><code>node_modules:</code> 依赖包</li><li><code>public：</code>存放生成的页面</li><li><code>scaffolds：</code>生成文章的一些模板</li><li><code>source：</code>用来存放你的文章</li><li><code>themes：</code>主题**</li><li><code>_config.yml:</code> 博客的配置文件**</li></ul><p>这样本地的网站配置也弄好啦，输入<code>hexo g</code>生成静态网页，然后输入<code>hexo s</code>打开本地服务器</p><pre><code>hexo ghexo server(或者简写:hexo s）)</code></pre><p>然后浏览器打开<a href="http://localhost:4000/，就可以看到我们的博客啦" target="_blank" rel="noopener">http://localhost:4000/，就可以看到我们的博客啦</a></p><h3 id="4-GitHub创建个人仓库"><a href="#4-GitHub创建个人仓库" class="headerlink" title="4.GitHub创建个人仓库"></a>4.<code>GitHub</code>创建个人仓库</h3><p>使用<code>github</code>，用来存放我们的网站。</p><p>新建一个项目仓库<code>New repository</code>，<br>输入自己的项目名字，后面一定要加<code>.github.io</code>后缀，<code>README</code>初始化也要勾上。</p><h3 id="5-生成SSH添加到GitHub（可跳过）"><a href="#5-生成SSH添加到GitHub（可跳过）" class="headerlink" title="5.生成SSH添加到GitHub（可跳过）"></a>5.生成<code>SSH</code>添加到<code>GitHub</code>（可跳过）</h3><p>生成<code>SSH</code>添加到<code>GitHub</code>，连接<code>Github</code>与本地。<br>右键打开<code>git bash</code>，然后输入下面命令：</p><pre><code>git config --global user.name "yourname"git config --global user.email "youremail"</code></pre><p>这里的<code>yourname</code>输入你的<code>GitHub</code>用户名，<code>youremail</code>输入你<code>GitHub</code>的邮箱。这样<code>GitHub</code>才能知道你是不是对应它的账户。例如我的：</p><pre><code>git config --global user.name "shw2018"git config --global user.email "hwsun@std.uestc.edu.cn"</code></pre><p>可以用以下两条，检查一下你有没有输对</p><pre><code>git config user.namegit config user.email</code></pre><p>然后创建<code>SSH</code>,一路回车</p><blockquote><p><code>ssh</code>，简单来讲，就是一个秘钥，其中，<code>id_rsa</code>是你这台电脑的私人秘钥，不能给别人看的，<code>id_rsa.pub</code>是公共秘钥，可以随便给别人看。把这个公钥放在<code>GitHub</code>上，这样当你链接<code>GitHub</code>自己的账户时，它就会根据公钥匹配你的私钥，当能够相互匹配时，才能够顺利的通过<code>git</code>上传你的文件到<code>GitHub</code>上。</p></blockquote><pre><code>ssh-keygen -t rsa -C "youremail"</code></pre><p>这个时候它会告诉你已经生成了<code>.ssh</code>的文件夹。在你的电脑中找到这个文件夹。或者<code>git bash</code>中输入</p><pre><code>cat ~/.ssh/id_rsa.pub</code></pre><p>将输出的内容复制到框中，点击确定保存。</p><p>打开<a href="http://github.com/" target="_blank" rel="noopener">github</a>，在头像下面点击<code>settings</code>，再点击<code>SSH and GPG keys</code>，新建一个<code>SSH</code>，名字随便取一个都可以，把你的<code>id_rsa.pub</code>里面的信息复制进去。</p><p>在<code>git bash</code>输入<code>ssh -T git@github.com</code>，出现你的用户名，那就成功了。</p><h3 id="6-将hexo部署到GitHub"><a href="#6-将hexo部署到GitHub" class="headerlink" title="6.将hexo部署到GitHub"></a>6.将<code>hexo</code>部署到<code>GitHub</code></h3><p>这一步，我们就可以将<code>hexo</code>和<code>GitHub</code>关联起来，打开博客根目录下的<code>_config.yml</code>文件，这是博客的配置文件，在这里你可以修改与博客配置相关的各种信息。</p><p>修改配置：</p><pre><code>deploy:  type: git  repository: https://github.com/Tian-JQ/Tian-JQ.github.io.git  branch: master</code></pre><p><code>repository</code>修改为你自己的<code>github</code>项目地址即可，就是部署时，告诉工具，将生成网页通过<code>git</code>方式上传到你对应的链接仓库中。</p><img src="https://cdn.jsdelivr.net/gh/Tian-JQ/images/img/githuburl.png" style="zoom:50%;"><p>这个时候需要先安装<code>deploy-git</code> ，也就是部署的命令,这样你才能用命令部署到<code>GitHub</code>。</p><pre><code>npm install hexo-deployer-git --save</code></pre><p>然后</p><pre><code>hexo chexo ghexo d</code></pre><p>其中 <code>hexo c (hexo clean)</code>清除之前生成的东西，也可以不加。 <code>hexo g (hexo generate)</code> 生成静态文章，<code>hexo d (hexo deploy)</code>部署文章，</p><blockquote><p>注意<code>deploy</code>时可能要你输入<code>username</code>和<code>password</code>。</p></blockquote><p>过一会儿就可以在<a href="http://yourname.github.io" target="_blank" rel="noopener">http://yourname.github.io</a> 这个网站看到你的博客了！</p><h3 id="7-设置个人域名"><a href="#7-设置个人域名" class="headerlink" title="7.设置个人域名"></a>7.设置个人域名</h3><p>现在你的个人网站的地址是<code>yourname.github.io</code>，如果觉得这个网址逼格不太够，这就需要你设置个人域名了。但是需要花钱。</p><blockquote><p><strong>这一步不是必要的，如果目前还不想买域名可以先跳过，继续看后面的，以后想买域名了在还看这块</strong></p></blockquote><p>首先你得购买一个专属域名，<code>xx</code>云都能买，看你个人喜好了。</p><p>这篇以腾讯云为例，腾讯云官网购买：<br><img src="https://cdn.jsdelivr.net/gh/Tian-JQ/images/img/9.png" style="zoom: 50%;"><br>然后实名认证后进入腾讯云控制台，点云解析进去，找到你刚买的域名，点进去添加两条解析记录：</p><img src="https://cdn.jsdelivr.net/gh/Tian-JQ/images/img/10.png" style="zoom:67%;"><p>然后打开你的<code>github</code>博客项目，点击<code>settings</code>，拉到下面<code>Custom domain</code>处，填上你自己的域名，保存：<br><img src="https://cdn.jsdelivr.net/gh/Tian-JQ/images/img/11.png" style="zoom: 67%;"></p><p>这时候你的项目根目录应该会出现一个名为<code>CNAME</code>的文件了。如果没有的话，打开你本地博客<code>/source</code>目录，我的是<code>D:\Study\MyBlog\source</code>，新建<code>CNAME</code>文件，注意没有后缀。然后在里面写上你的域名，保存。最后运行<code>hexo g</code>、<code>hexo d</code>上传到<code>github</code>。</p><p>过不了多久，再打开你的浏览器，输入你自己的专属域名，就可以看到搭建的网站啦！</p><h3 id="8-发布文章"><a href="#8-发布文章" class="headerlink" title="8.发布文章"></a>8.发布文章</h3><p>首先在博客根目录下右键打开<code>git bash</code>，安装一个扩展<code>npm i hexo-deployer-git</code>。</p><p>然后输入<code>hexo new post "article title"</code>，新建一篇文章。</p><p>然后打开<code>D:\Document\Blog\source\_posts</code>的目录，可以发现下面多了一个文件夹和一个<code>.md</code>文件，就是你的文章文件啦。<br>使用md文档编写<code>markdown</code>文件，可以实时预览。<br>编写完markdown文件后，根目录下输入<code>hexo g</code>生成静态网页，然后输入<code>hexo s</code>可以本地预览效果，最后输入<code>hexo d</code>上传到<code>github</code>上。这时打开你的<code>github.io</code>主页就能看到发布的文章啦。</p><h2 id="二-个性化"><a href="#二-个性化" class="headerlink" title="二 个性化"></a>二 个性化</h2><p>主题大全：<a href="https://hexo.io/themes/" target="_blank" rel="noopener">https://hexo.io/themes/</a></p><p>推荐主题：<a href="https://github.com/blinkfox/hexo-theme-matery/blob/develop/README_CN.md" target="_blank" rel="noopener">https://github.com/blinkfox/hexo-theme-matery/blob/develop/README_CN.md</a></p><h3 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h3><p>修改 Hexo 根目录下的 <code>_config.yml</code> 的 <code>theme</code> 的值：<code>theme: hexo-theme-matery</code></p><pre><code>其他个性化设置可参考：https://github.com/blinkfox/hexo-theme-matery/blob/develop/README_CN.mdhttps://blinkfox.github.io/2018/09/28/qian-duan/hexo-bo-ke-zhu-ti-zhi-hexo-theme-matery-de-jie-shao/#toc-heading-9</code></pre><h2 id="三-图床"><a href="#三-图床" class="headerlink" title="三 图床"></a>三 图床</h2><p>编写md文档时，图片处理及其让人头疼，一旦本地图片丢失，md文档中图片就会无法显示，所以我们需要将图保存到图床，即使本地图片丢失，md也不受影响。</p><p>免费图床方案：<code>PicGo+jsdelivr+github</code></p><p><a href="https://tian-jq.github.io/2020/02/01/tu-chuang/" target="_blank" rel="noopener">教程链接</a></p><p><u>—————————————————————————————————————————-</u></p><blockquote><p>参考：</p><p>特别鸣谢！</p><p><a href="https://www.cnblogs.com/shwee/p/11421156.html" target="_blank" rel="noopener">https://www.cnblogs.com/shwee/p/11421156.html</a></p><p><a href="https://301technology.cn/2020/01/19/hexoblog/#前言" target="_blank" rel="noopener">https://301technology.cn/2020/01/19/hexoblog/#%E5%89%8D%E8%A8%80</a></p><p>主题：</p><p><a href="https://github.com/blinkfox/hexo-theme-matery/blob/develop/README_CN.md" target="_blank" rel="noopener">https://github.com/blinkfox/hexo-theme-matery/blob/develop/README_CN.md</a></p><p>图床：</p><p><a href="https://301technology.cn/2020/01/17/image/#本文用到的工具或网站" target="_blank" rel="noopener">https://301technology.cn/2020/01/17/image/#%E6%9C%AC%E6%96%87%E7%94%A8%E5%88%B0%E7%9A%84%E5%B7%A5%E5%85%B7%E6%88%96%E7%BD%91%E7%AB%99</a></p><p>bilibili:</p><p><a href="https://www.bilibili.com/video/av65336062?from=search&amp;seid=9800526859366131449" target="_blank" rel="noopener">https://www.bilibili.com/video/av65336062?from=search&amp;seid=9800526859366131449</a></p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> github </tag>
            
            <tag> Hexo </tag>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
